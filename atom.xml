<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhangHy&#39;s Zone!</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://weibo.com/"/>
  <updated>2018-12-03T10:57:55.059Z</updated>
  <id>http://weibo.com/</id>
  
  <author>
    <name>ZhangHy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP操作数组</title>
    <link href="http://weibo.com/2018/12/03/PHP%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/"/>
    <id>http://weibo.com/2018/12/03/PHP操作数组/</id>
    <published>2018-12-03T10:06:35.000Z</published>
    <updated>2018-12-03T10:57:55.059Z</updated>
    
    <content type="html"><![CDATA[<p>数组的合并，追加，删除，拆分，查找等</p>
<h2 id="1-合并数组"><a href="#1-合并数组" class="headerlink" title="1. 合并数组"></a>1. 合并数组</h2><p>array_merge()函数将数组合并到一起，返回一个联合的数组。所得到的数组以第一个输入数组参数开始，按后面数组参数出现的顺序依次迫加。其形式为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array array_merge (array array1 array2…,arrayN)</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这个函数将一个或多个数组的单元合并起来，一个数组中的值附加在前一个数组的后面。返回作为结果的数组。</p>
<p>如果输入的数组中有相同的字符串键名，则该键名后面的值将覆盖前一个值。然而，如果数组包含数字键名，后面的值将不会覆盖原来的值，而是附加到后面。</p>
<p>如果只给了一个数组并且该数组是数字索引的，则键名会以连续方式重新索引。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"apple"</span>,<span class="string">"banana"</span>,<span class="string">"pear"</span>);  </div><div class="line"><span class="variable">$numbered</span> = array(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);  </div><div class="line"><span class="variable">$cards</span> = array_merge(<span class="variable">$fruits</span>, <span class="variable">$numbered</span>);  </div><div class="line">print_r(<span class="variable">$cards</span>);  </div><div class="line">  </div><div class="line">// output  </div><div class="line">// Array ( [0] =&gt; apple [1] =&gt; banana [2] =&gt; pear [3] =&gt; 1 [4] =&gt; 2 [5] =&gt; 3 )  </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h2 id="2-追加数组"><a href="#2-追加数组" class="headerlink" title="2. 追加数组"></a>2. 追加数组</h2><p>array_merge_recursive()函数与array_merge()相同，可以将两个或多个数组合并在一起，形成一个联合的数组．两者之间的区别在于，当某个输入数组中的某个键己经存在于结果数组中时该函数会采取不同的处理方式．array_merge()会覆盖前面存在的键/值对， 替换为当前输入数组中的键/值对，而array_merge_recursive()将把两个值合并在一起，形成一个新的数组，并以原有的键作为数组名。 还有一个数组合并的形式，就是递归追加数组。其形式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array array_merge_recursive(array array1,array array2[…,array arrayN])</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line"><span class="variable">$fruit1</span> = array(<span class="string">"apple"</span> =&gt; <span class="string">"red"</span>, <span class="string">"banana"</span> =&gt; <span class="string">"yellow"</span>);  </div><div class="line"><span class="variable">$fruit2</span> = array(<span class="string">"pear"</span> =&gt; <span class="string">"yellow"</span>, <span class="string">"apple"</span> =&gt; <span class="string">"green"</span>);  </div><div class="line"><span class="variable">$result</span> = array_merge_recursive(<span class="variable">$fruit1</span>, <span class="variable">$fruit2</span>);  </div><div class="line">print_r(<span class="variable">$result</span>);  </div><div class="line">  </div><div class="line">// output  </div><div class="line">// Array ( [apple] =&gt; Array ( [0] =&gt; red [1] =&gt; green ) [banana] =&gt; yellow [pear] =&gt; yellow )  </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>现在键 apple 指向一个数组，这个数组由两个颜色值组成的索引数组。</p>
<h2 id="3-连接数组"><a href="#3-连接数组" class="headerlink" title="3. 连接数组"></a>3. 连接数组</h2><p>array_combine()函数会得到一个新数组，它由一组提交的键和对应的值组成。其形式为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">array array_combine(array keys,array values)  </div><div class="line">``` </div><div class="line">注意，两个输入数组必须大小相同，不能为空。示例如下</div><div class="line">``` bash</div><div class="line">&lt;?php  </div><div class="line"><span class="variable">$name</span> = array(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>);  </div><div class="line"><span class="variable">$color</span> = array(<span class="string">"red"</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>);  </div><div class="line"><span class="variable">$fruit</span> = array_combine(<span class="variable">$name</span>, <span class="variable">$color</span>);  </div><div class="line">print_r(<span class="variable">$fruit</span>);  </div><div class="line">  </div><div class="line">// output  </div><div class="line">// Array ( [apple] =&gt; red [banana] =&gt; yellow [orange] =&gt; orange )  </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="4-拆分数组-array-slice"><a href="#4-拆分数组-array-slice" class="headerlink" title="4. 拆分数组 array_slice()"></a>4. 拆分数组 array_slice()</h2><p>array_slice()函数将返回数组中的一部分，从键offset开始，到offset+length位置结束。其形式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">array array_slice (array array, int offset[,int length]) </div><div class="line">```  </div><div class="line"></div><div class="line">offset 为正值时，拆分将从距数组开头的offset 位置开始；如果offset 为负值，则拆分从距数组末尾的offset 位置开始。如果省略了可选参数length，则拆分将从offset 开始，一直到数组的最后一个元素。如果给出了length 且为正数，则会在距数组开头的offset+length 位置结束。相反，如果给出了length且为负数，则在距数组开头的count(input_array)-|length|位置结束。考虑一个例子：</div><div class="line"></div><div class="line">```bash</div><div class="line">&lt;?php  </div><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Lemon"</span>, <span class="string">"Watermelon"</span>);  </div><div class="line"><span class="variable">$subset</span> = array_slice(<span class="variable">$fruits</span>, 3);  </div><div class="line">print_r(<span class="variable">$subset</span>);  </div><div class="line">  </div><div class="line">// output  </div><div class="line">// Array ( [0] =&gt; Pear [1] =&gt; Grape [2] =&gt; Lemon [3] =&gt; Watermelon )  </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>然后我们使用下负长度：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Lemon"</span>, <span class="string">"Watermelon"</span>);  </div><div class="line"><span class="variable">$subset</span> = array_slice(<span class="variable">$fruits</span>, 2, -2);  </div><div class="line">print_r(<span class="variable">$subset</span>);  </div><div class="line"></div><div class="line">// output  </div><div class="line">// Array ( [0] =&gt; Orange [1] =&gt; Pear [2] =&gt; Grape )  </div><div class="line">?&gt;  </div><div class="line">```</div></pre></td></tr></table></figure></p>
<h2 id="5-接合数组-array-splice"><a href="#5-接合数组-array-splice" class="headerlink" title="5. 接合数组 array_splice()"></a>5. 接合数组 array_splice()</h2><p>array_splice()函数会删除数组中从offset开始到offset+length 结束的所有元素，并以数组的形式返回所删除的元素。其形式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">array array_splice ( array array , int offset[,length[,array replacement]])   </div><div class="line">``` </div><div class="line"></div><div class="line">offset 为正值时，则接合将从距数组开头的offset 位置开始，offset 为负值时，接合将从距数组末尾的offset 位置开始。如果忽略可选的length 参数，则从offset 位置开始到数组结束之间的所有元素都将被删除。如果给出了length 且为正值，则接合将在距数组开头的offset + leng th 位置结束。相反，如果给出了length且为负值，则结合将在距数组开头的count(input_array)-length的位置结束。实例如下：</div><div class="line"></div><div class="line">``` bash</div><div class="line">&lt;?php    </div><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Lemon"</span>, <span class="string">"Watermelon"</span>);  </div><div class="line"><span class="variable">$subset</span> = array_splice(<span class="variable">$fruits</span>, 4);  </div><div class="line">  </div><div class="line">print_r(<span class="variable">$fruits</span>);  </div><div class="line">print_r(<span class="variable">$subset</span>);  </div><div class="line">  </div><div class="line">// output  </div><div class="line">// Array ( [0] =&gt; Apple [1] =&gt; Banana [2] =&gt; Orange [3] =&gt; Pear )   </div><div class="line">// Array ( [0] =&gt; Grape [1] =&gt; Lemon [2] =&gt; Watermelon )  </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>可以使用可选参数replacement来指定取代目标部分的数组。实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Lemon"</span>, <span class="string">"Watermelon"</span>);  </div><div class="line"><span class="variable">$subset</span> = array_splice(<span class="variable">$fruits</span>, 2, -1, array(<span class="string">"Green Apple"</span>, <span class="string">"Red Apple"</span>));  </div><div class="line">  </div><div class="line">print_r(<span class="variable">$fruits</span>);  </div><div class="line">print_r(<span class="variable">$subset</span>);  </div><div class="line">  </div><div class="line">// output  </div><div class="line">// Array ( [0] =&gt; Apple [1] =&gt; Banana [2] =&gt; Green Apple [3] =&gt; Red Apple [4] =&gt; Watermelon )   </div><div class="line">// Array ( [0] =&gt; Orange [1] =&gt; Pear [2] =&gt; Grape [3] =&gt; Lemon )  </div><div class="line">?&gt;  </div><div class="line">```</div></pre></td></tr></table></figure>
<p>从程序可以很清楚看到这个函数的使用方法了。</p>
<h2 id="6-数组的交集-array-intersect"><a href="#6-数组的交集-array-intersect" class="headerlink" title="6. 数组的交集 array_intersect()"></a>6. 数组的交集 array_intersect()</h2><p>array_intersect()函数返回一个保留了键的数组，这个数组只由第一个数组中出现的且在其他每个输入数组中都出现的值组成。其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">array array_intersect(array array1,array array2[,arrayN…])  </div><div class="line">``` </div><div class="line">下面这个例子将返回在<span class="variable">$fruit1</span>数组中出现的且在<span class="variable">$fruit2</span>和<span class="variable">$fruit3</span>中也出现的所有的水果：</div><div class="line"></div><div class="line">``` bash</div><div class="line">&lt;?php  </div><div class="line"><span class="variable">$fruit1</span> = array(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>,<span class="string">"Orange"</span>);  </div><div class="line"><span class="variable">$fruit2</span> = array(<span class="string">"Pear"</span>,<span class="string">"Apple"</span>,<span class="string">"Grape"</span>);  </div><div class="line"><span class="variable">$fruit3</span> = array(<span class="string">"Watermelon"</span>,<span class="string">"Orange"</span>,<span class="string">"Apple"</span>);  </div><div class="line"><span class="variable">$intersection</span> = array_intersect(<span class="variable">$fruit1</span>, <span class="variable">$fruit2</span>, <span class="variable">$fruit3</span>);  </div><div class="line">print_r(<span class="variable">$intersection</span>);  </div><div class="line">  </div><div class="line">// output  </div><div class="line">// Array ( [0] =&gt; Apple )  </div><div class="line">?&gt;  </div><div class="line">```</div></pre></td></tr></table></figure>
<p>只有在两个元素相等且具有相同的数据类型时，array_intersect()函数才会认为它们是相同的。</p>
<h2 id="7-关联数组的交集-array-intersect-assoc"><a href="#7-关联数组的交集-array-intersect-assoc" class="headerlink" title="7. 关联数组的交集 array_intersect_assoc()"></a>7. 关联数组的交集 array_intersect_assoc()</h2><p>函数array_intersect_assoc()与array_intersect()基本相同，只不过他在比较中还考虑了数组的键。因此，只有在第一个数组中出现，且在所有其他输入数组中也出现的键/值对才返回到结果数组中。<br>形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">array array_intersect_assoc(array array1,array array2[,arrayN…])  </div><div class="line">``` </div><div class="line"></div><div class="line">下面的例子返回了出现在<span class="variable">$fruit1</span>数组中，也同时出现在<span class="variable">$fruit2</span>与<span class="variable">$fruit3</span>中的所有键/值对：</div><div class="line"></div><div class="line">``` bash</div><div class="line">&lt;?php  </div><div class="line"><span class="variable">$fruit1</span> = array(<span class="string">"red"</span>=&gt;<span class="string">"Apple"</span>,<span class="string">"yellow"</span>=&gt;<span class="string">"Banana"</span>,<span class="string">"orange"</span>=&gt;<span class="string">"Orange"</span>);  </div><div class="line"><span class="variable">$fruit2</span> = array(<span class="string">"yellow"</span>=&gt;<span class="string">"Pear"</span>,<span class="string">"red"</span>=&gt;<span class="string">"Apple"</span>,<span class="string">"purple"</span>=&gt;<span class="string">"Grape"</span>);  </div><div class="line"><span class="variable">$fruit3</span> = array(<span class="string">"green"</span>=&gt;<span class="string">"Watermelon"</span>,<span class="string">"orange"</span>=&gt;<span class="string">"Orange"</span>,<span class="string">"red"</span>=&gt;<span class="string">"Apple"</span>);  </div><div class="line"><span class="variable">$intersection</span> = array_intersect_assoc(<span class="variable">$fruit1</span>, <span class="variable">$fruit2</span>, <span class="variable">$fruit3</span>);  </div><div class="line">print_r(<span class="variable">$intersection</span>);  </div><div class="line">  </div><div class="line">// output  </div><div class="line">// Array ( [red] =&gt; Apple )  </div><div class="line">?&gt;  </div><div class="line">```</div></pre></td></tr></table></figure>
<h2 id="8-数组的差集-array-diff"><a href="#8-数组的差集-array-diff" class="headerlink" title="8. 数组的差集 array_diff()"></a>8. 数组的差集 array_diff()</h2><p>函数array_diff()返回出现在第一个数组中但其他输入数组中没有的值。这个功能与array_intersect()相反。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">array array_diff(array array1,array array2[,arrayN…])  </div><div class="line">``` </div><div class="line"></div><div class="line">实例如下：</div><div class="line"></div><div class="line">``` bash</div><div class="line">&lt;?php  </div><div class="line"><span class="variable">$fruit1</span> = array(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>,<span class="string">"Orange"</span>);  </div><div class="line"><span class="variable">$fruit2</span> = array(<span class="string">"Pear"</span>,<span class="string">"Apple"</span>,<span class="string">"Grape"</span>);  </div><div class="line"><span class="variable">$fruit3</span> = array(<span class="string">"Watermelon"</span>,<span class="string">"Orange"</span>,<span class="string">"Apple"</span>);  </div><div class="line"><span class="variable">$intersection</span> = array_diff(<span class="variable">$fruit1</span>, <span class="variable">$fruit2</span>, <span class="variable">$fruit3</span>);  </div><div class="line">print_r(<span class="variable">$intersection</span>);  </div><div class="line">  </div><div class="line">// output  </div><div class="line">// Array ( [1] =&gt; Banana )  </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h2 id="9-关联数组的差集-array-diff-assoc"><a href="#9-关联数组的差集-array-diff-assoc" class="headerlink" title="9. 关联数组的差集 array_diff_assoc()"></a>9. 关联数组的差集 array_diff_assoc()</h2><p>函数array_diff_assoc()与array_diff()基本相同，只是它在比较时还考虑了数组的键。因此，只在第一个数组中出现而不再其他输入数组中出现的键/值对才会返回到结果数组中。其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">array array_diff_assoc(array array1,array array2[,arrayN…])  </div><div class="line">``` </div><div class="line"></div><div class="line">下面的例子只返回了[yellow] =&gt; Banana,因为这个特殊的键/值对出现在<span class="variable">$fruit1</span>中，而在<span class="variable">$fruit2</span>和<span class="variable">$fruit3</span>中都不存在。</div><div class="line"></div><div class="line">``` bash</div><div class="line">&lt;?php  </div><div class="line"><span class="variable">$fruit1</span> = array(<span class="string">"red"</span>=&gt;<span class="string">"Apple"</span>,<span class="string">"yellow"</span>=&gt;<span class="string">"Banana"</span>,<span class="string">"orange"</span>=&gt;<span class="string">"Orange"</span>);  </div><div class="line"><span class="variable">$fruit2</span> = array(<span class="string">"yellow"</span>=&gt;<span class="string">"Pear"</span>,<span class="string">"red"</span>=&gt;<span class="string">"Apple"</span>,<span class="string">"purple"</span>=&gt;<span class="string">"Grape"</span>);  </div><div class="line"><span class="variable">$fruit3</span> = array(<span class="string">"green"</span>=&gt;<span class="string">"Watermelon"</span>,<span class="string">"orange"</span>=&gt;<span class="string">"Orange"</span>,<span class="string">"red"</span>=&gt;<span class="string">"Apple"</span>);  </div><div class="line"><span class="variable">$intersection</span> = array_diff_assoc(<span class="variable">$fruit1</span>, <span class="variable">$fruit2</span>, <span class="variable">$fruit3</span>);  </div><div class="line">print_r(<span class="variable">$intersection</span>);  </div><div class="line">  </div><div class="line">// output  </div><div class="line">// Array ( [yellow] =&gt; Banana )  </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>使用数组的过程中经常要遍历数组。通常需要遍历数组并获得各个键或值（或者同时获得键和值），所以毫不奇怪，PHP为此提供了一些函数来满足需求。许多函数能完成两项任务，不仅能获取当前指针位置的键或值，还能将指针移向下一个适当的位置。</p>
<h2 id="10-获取当前数组键-key"><a href="#10-获取当前数组键-key" class="headerlink" title="10. 获取当前数组键 key()"></a>10. 获取当前数组键 key()</h2><p>key()函数返回input_array中当前指针所在位置的键。其形式如下<br>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mixed key(array array)</div></pre></td></tr></table></figure></p>
<p>下面的例子通过迭代处理数组并移动指针来输出$fruits数组的键：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"apple"</span>=&gt;<span class="string">"red"</span>, <span class="string">"banana"</span>=&gt;<span class="string">"yellow"</span>);  </div><div class="line"><span class="keyword">while</span> (<span class="variable">$key</span> = key(<span class="variable">$fruits</span>)) &#123;  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s &lt;br /&gt;"</span>, <span class="variable">$key</span>);  </div><div class="line">    next(<span class="variable">$fruits</span>);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">// apple   </div><div class="line">// banana  </div><div class="line">```</div></pre></td></tr></table></figure>
<p>注意，每次调用key()时不会移动指针。为此需要使用next()函数，这个函数的唯一作用就是完成推进指针的任务。</p>
<h2 id="11-获取当前数组值-current"><a href="#11-获取当前数组值-current" class="headerlink" title="11. 获取当前数组值 current()"></a>11. 获取当前数组值 current()</h2><p>current()函数返回数组中当前指针所在位置的数组值。其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mixed current(array array)  </div><div class="line">``` </div><div class="line"></div><div class="line">下面修改前面的例子，这一次我们要获取数组值：</div><div class="line"></div><div class="line">``` bash</div><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"apple"</span>=&gt;<span class="string">"red"</span>, <span class="string">"banana"</span>=&gt;<span class="string">"yellow"</span>);  </div><div class="line"><span class="keyword">while</span> (<span class="variable">$fruit</span> = current(<span class="variable">$fruits</span>)) &#123;  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s &lt;br /&gt;"</span>, <span class="variable">$fruit</span>);  </div><div class="line">    next(<span class="variable">$fruits</span>);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">// red   </div><div class="line">// yellow   </div><div class="line">```</div></pre></td></tr></table></figure>
<h2 id="12-获取当前数组键和值-each"><a href="#12-获取当前数组键和值-each" class="headerlink" title="12. 获取当前数组键和值 each()"></a>12. 获取当前数组键和值 each()</h2><p>each()函数返回input_array的当前键/值对，并将指针推进一个位置。其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">array each(array array)  </div><div class="line">``` </div><div class="line">返回的数组包含四个键，键0和key包含键名，而键1和value包含相应的数据。如果执行each()前指针位于数组末尾，则返回<span class="literal">false</span>。</div><div class="line"></div><div class="line">``` bash</div><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"pear"</span>);  </div><div class="line">print_r ( each(<span class="variable">$fruits</span>) );  </div><div class="line">  </div><div class="line">// Array ( [1] =&gt; apple [value] =&gt; apple [0] =&gt; 0 [key] =&gt; 0 )  </div><div class="line">``` </div><div class="line">each() 经常和 list() 结合使用来遍历数组。本例与上例类似，不过循环输出了整个数组：</div><div class="line"></div><div class="line">``` bash</div><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"pear"</span>);  </div><div class="line">reset(<span class="variable">$fruits</span>);  </div><div class="line">  </div><div class="line"><span class="keyword">while</span> (list(<span class="variable">$key</span>, <span class="variable">$val</span>) = each(<span class="variable">$fruits</span>))  </div><div class="line">    &#123;  </div><div class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$key</span> =&gt; <span class="variable">$val</span>&lt;br /&gt;"</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">// 0 =&gt; apple  </div><div class="line">// 1 =&gt; banana  </div><div class="line">// 2 =&gt; orange  </div><div class="line">// 3 =&gt; pear  </div><div class="line">```</div></pre></td></tr></table></figure>
<p>因为将一个数组赋值给另一个数组时会重置原来的数组指针，因此在上例中如果我们在循环内部将 $fruits 赋给了另一个变量的话将会导致无限循环。<br>这就完成了数组的遍历。<br>查找、筛选与搜索数组元素是数组操作的一些常见功能。下面来介绍一下几个相关的函数。 </p>
<h2 id="13-in-array-函数"><a href="#13-in-array-函数" class="headerlink" title="13. in_array()函数"></a>13. in_array()函数</h2><p>in_array()函数在一个数组汇总搜索一个特定值，如果找到这个值返回true，否则返回false。其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">boolean in_array(mixed needle,array haystack[,boolean strict]);  </div><div class="line">``` </div><div class="line"></div><div class="line">来看下面的例子，查找变量apple是否已经在数组中，如果在，则输出一段信息：</div><div class="line"></div><div class="line">``` bash</div><div class="line"><span class="variable">$fruit</span> = <span class="string">"apple"</span>;   </div><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"apple"</span>,<span class="string">"banana"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>);   </div><div class="line"><span class="keyword">if</span>( in_array(<span class="variable">$fruit</span>,<span class="variable">$fruits</span>) )    </div><div class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$fruit</span> 已经在数组中"</span>;  </div><div class="line">```</div></pre></td></tr></table></figure>
<p>第三个参数可选，它强制in_array()在搜索时考虑类型。</p>
<h2 id="14-array-key-exists-函数"><a href="#14-array-key-exists-函数" class="headerlink" title="14. array_key_exists()函数"></a>14. array_key_exists()函数</h2><p>如果在一个数组中找到一个指定的键，函数array_key_exists()返回true，否则返回false。其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean array_key_exists(mixed key,array array);</div></pre></td></tr></table></figure>
<p>下面的例子将在数组键中搜索apple，如果找到，将输出这个水果的颜色：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$fruit</span>[<span class="string">"apple"</span>] = <span class="string">"red"</span>;  </div><div class="line"><span class="variable">$fruit</span>[<span class="string">"banana"</span>] = <span class="string">"yellow"</span>;  </div><div class="line"><span class="variable">$fruit</span>[<span class="string">"pear"</span>] = <span class="string">"green"</span>;  </div><div class="line"><span class="keyword">if</span>(array_key_exists(<span class="string">"apple"</span>, <span class="variable">$fruit</span>))&#123;  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"apple's color is %s"</span>,<span class="variable">$fruit</span>[<span class="string">"apple"</span>]);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">//apple<span class="string">'s color is red  </span></div><div class="line"><span class="string">```</span></div></pre></td></tr></table></figure>
<h2 id="15-array-search-函数"><a href="#15-array-search-函数" class="headerlink" title="15. array_search()函数"></a>15. array_search()函数</h2><p>array_search()函数在一个数组中搜索一个指定的值，如果找到则返回相应的键，否则返回false。其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mixed array_search(mixed needle,array haystack[,boolean strict])  </div><div class="line">``` </div><div class="line"></div><div class="line">下面的例子在<span class="variable">$fruits</span>中搜索一个特定的日期（December 7），如果找到，则返回相应州的有关信息：</div><div class="line"></div><div class="line">``` bash</div><div class="line"><span class="variable">$fruits</span>[<span class="string">"apple"</span>] = <span class="string">"red"</span>;  </div><div class="line"><span class="variable">$fruits</span>[<span class="string">"banana"</span>] = <span class="string">"yellow"</span>;  </div><div class="line"><span class="variable">$fruits</span>[<span class="string">"watermelon"</span>]=<span class="string">"green"</span>;  </div><div class="line"><span class="variable">$founded</span> = array_search(<span class="string">"green"</span>, <span class="variable">$fruits</span>);  </div><div class="line"><span class="keyword">if</span>(<span class="variable">$founded</span>)   </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s was founded on %s."</span>,<span class="variable">$founded</span>, <span class="variable">$fruits</span>[<span class="variable">$founded</span>]);  </div><div class="line">  </div><div class="line">//watermelon was founded on green.  </div><div class="line">```</div></pre></td></tr></table></figure>
<h2 id="16-array-keys-函数"><a href="#16-array-keys-函数" class="headerlink" title="16. array_keys()函数"></a>16. array_keys()函数</h2><p>array_keys()函数返回一个数组，其中包含所搜索数组中找到的所有键。其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">array array_keys(array array[,mixed search_value])  </div><div class="line">```</div></pre></td></tr></table></figure>
<p>如果包含可选参数search_value，则只会返回与该值匹配的键。下面的例子将输出$fruit数组中找到的所有数组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$fruits</span>[<span class="string">"apple"</span>] = <span class="string">"red"</span>;  </div><div class="line"><span class="variable">$fruits</span>[<span class="string">"banana"</span>] = <span class="string">"yellow"</span>;  </div><div class="line"><span class="variable">$fruits</span>[<span class="string">"watermelon"</span>]=<span class="string">"green"</span>;  </div><div class="line"><span class="variable">$keys</span> = array_keys(<span class="variable">$fruits</span>);  </div><div class="line">print_r(<span class="variable">$keys</span>);  </div><div class="line">  </div><div class="line">//Array ( [0] =&gt; apple [1] =&gt; banana [2] =&gt; watermelon )  </div><div class="line">```</div></pre></td></tr></table></figure>
<h2 id="17-array-values-函数"><a href="#17-array-values-函数" class="headerlink" title="17. array_values()函数"></a>17. array_values()函数</h2><p>array_values()函数返回一个数组中的所有值，并自动为返回的数组提供数值索引。其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">array array_values(array array)  </div><div class="line">```</div></pre></td></tr></table></figure>
<p>下面的例子将获取$fruits中找到的各元素的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$fruits</span>[<span class="string">"apple"</span>] = <span class="string">"red"</span>;  </div><div class="line"><span class="variable">$fruits</span>[<span class="string">"banana"</span>] = <span class="string">"yellow"</span>;  </div><div class="line"><span class="variable">$fruits</span>[<span class="string">"watermelon"</span>]=<span class="string">"green"</span>;  </div><div class="line"><span class="variable">$values</span> = array_values(<span class="variable">$fruits</span>);  </div><div class="line">print_r(<span class="variable">$values</span>);  </div><div class="line">  </div><div class="line">//Array ( [0] =&gt; red [1] =&gt; yellow [2] =&gt; green )  </div><div class="line">```</div></pre></td></tr></table></figure>
<p>有时候我们需要扩展一个数组，或者删掉数组的一部分，PHP为扩展和缩小数组提供了一些函数。对于那些希望模仿各种队列实现（FIFO、LIFO） 的程序员来说，这些函数可以提供便利。顾名思义，从这些函数的函数名（push、pop、shift和unshift）就清楚地反映出其作用。<br>PS：传统的队列是一种数据结构，删除元素与加入元素的顺序相同，就称为先进先出，或FIFO。相反，栈是另外一种数据结构，其中删除元素的顺序与加入时的顺序相反，这成为后进先出，或LIFO。</p>
<h2 id="18-在数组头添加元素"><a href="#18-在数组头添加元素" class="headerlink" title="18. 在数组头添加元素"></a>18. 在数组头添加元素</h2><p>array_unshift()函数在数组头添加元素。所有己有的数值键都会相应地修改，以反映其在数组中的新位置，但是关联键不受影响。其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int array_unshift(array array,mixed variable[,mixed variable])  </div><div class="line">```</div></pre></td></tr></table></figure>
<p>下面这个例子在$fruits数组前面添加了两种水果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"apple"</span>,<span class="string">"banana"</span>);  </div><div class="line">array_unshift(<span class="variable">$fruits</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>)  </div><div class="line">// <span class="variable">$fruits</span> = array(<span class="string">"orange"</span>,<span class="string">"pear"</span>,<span class="string">"apple"</span>,<span class="string">"banana"</span>);  </div><div class="line">```</div></pre></td></tr></table></figure>
<h2 id="19-在数组尾添加元素"><a href="#19-在数组尾添加元素" class="headerlink" title="19. 在数组尾添加元素"></a>19. 在数组尾添加元素</h2><p>array_push()函数的返回值是int型，是压入数据后数组中元素的个数，可以为此函数传递多个变量作为参数，同时向数组压入多个变量。其形式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(array array,mixed variable [,mixed variable...])  </div><div class="line">``` </div><div class="line"></div><div class="line">下面这个例子在<span class="variable">$fruits</span>数组中又添加了两个水果：</div><div class="line"></div><div class="line">``` bash</div><div class="line"><span class="variable">$fruits</span> = array(<span class="string">"apple"</span>,<span class="string">"banana"</span>);  </div><div class="line">array_push(<span class="variable">$fruits</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>)  </div><div class="line">//<span class="variable">$fruits</span> = array(<span class="string">"apple"</span>,<span class="string">"banana"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>)  </div><div class="line">```</div></pre></td></tr></table></figure>
<h2 id="20-从数组头删除值"><a href="#20-从数组头删除值" class="headerlink" title="20. 从数组头删除值"></a>20. 从数组头删除值</h2><p>array_shift()函数删除并返回数组中找到的元素。其结果是，如果使用的是数值健，则所有相应的值都会下移，而使用关联键的数组不受影响。其形式为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mixed array_shift(array array)  </div><div class="line">```</div></pre></td></tr></table></figure>
<p>下面的例子删除了$fruits数组中的第一个元素apple：</p>
<pre><code class="bash"><span class="variable">$fruits</span> = array(<span class="string">"apple"</span>,<span class="string">"banana"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>);  
<span class="variable">$fruit</span> = array_shift(<span class="variable">$fruits</span>);  
// <span class="variable">$fruits</span> = array(<span class="string">"banana"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>)  
// <span class="variable">$fruit</span> = <span class="string">"apple"</span>;
</code></pre>
<h2 id="21-从数组尾删除元素"><a href="#21-从数组尾删除元素" class="headerlink" title="21. 从数组尾删除元素"></a>21. 从数组尾删除元素</h2><p>array_pop()函数删除并返回数组的最后一个元素。其形式为：</p>
<pre><code class="bash">mixed array_pop(aray target_array);
</code></pre>
<p>下面的例子从$states数组删除了最后的一个州：</p>
<pre><code class="bash"><span class="variable">$fruits</span> = array(<span class="string">"apple"</span>,<span class="string">"banana"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>);  
<span class="variable">$fruit</span> = array_pop(<span class="variable">$fruits</span>);  
//<span class="variable">$fruits</span> = array(<span class="string">"apple"</span>,<span class="string">"banana"</span>,<span class="string">"orange"</span>);  
//<span class="variable">$fruit</span> = <span class="string">"pear"</span>;
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组的合并，追加，删除，拆分，查找等&lt;/p&gt;
&lt;h2 id=&quot;1-合并数组&quot;&gt;&lt;a href=&quot;#1-合并数组&quot; class=&quot;headerlink&quot; title=&quot;1. 合并数组&quot;&gt;&lt;/a&gt;1. 合并数组&lt;/h2&gt;&lt;p&gt;array_merge()函数将数组合并到一起，返回一个联合的数组。所得到的数组以第一个输入数组参数开始，按后面数组参数出现的顺序依次迫加。其形式为：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;array array_merge (array array1 array2…,arrayN)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://weibo.com/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>github上传项目导致gitbash报错的问题</title>
    <link href="http://weibo.com/2018/12/03/github%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%AF%BC%E8%87%B4gitbash%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://weibo.com/2018/12/03/github上传项目导致gitbash报错的问题/</id>
    <published>2018-12-03T09:15:43.000Z</published>
    <updated>2018-12-03T09:23:34.033Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚上传blog的时候，git bash一直报错，主要以下两个错误：<br>1、Run config : Please tell me who you are<br>2、fatal: HttpRequestException encountered<br><a id="more"></a></p>
<h2 id="报错1解决方案"><a href="#报错1解决方案" class="headerlink" title="报错1解决方案"></a>报错1解决方案</h2><p>原因：没有认证自己的名字和邮箱<br>解决方案1：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.email <span class="string">"you@example.com"</span>  </div><div class="line">git config --global user.name <span class="string">"Your Name"</span></div></pre></td></tr></table></figure></p>
<p>解决方案2：<br>在项目文件夹下找到.git文件夹，然后用nodepad++打开里面的config文件，添加如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[user]</div><div class="line">    name = XXX(自己的名称)</div><div class="line">    email = XXXX(邮箱)</div></pre></td></tr></table></figure></p>
<h2 id="报错2解决方案"><a href="#报错2解决方案" class="headerlink" title="报错2解决方案"></a>报错2解决方案</h2><p>原因：Github 禁用了TLS v1.0 and v1.1，必须更新Windows的git凭证管理器，才行。<br>解决方案：<br><a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/tag/v1.14.0" target="_blank" rel="external">下载</a><br>点击下载安装 GCMW-1.14.0.exe ,问题就解决了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚上传blog的时候，git bash一直报错，主要以下两个错误：&lt;br&gt;1、Run config : Please tell me who you are&lt;br&gt;2、fatal: HttpRequestException encountered&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS加密七种方法</title>
    <link href="http://weibo.com/2018/12/03/JS%E5%8A%A0%E5%AF%86%E4%B8%83%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://weibo.com/2018/12/03/JS加密七种方法/</id>
    <published>2018-12-03T08:08:18.000Z</published>
    <updated>2018-12-03T08:35:56.256Z</updated>
    
    <content type="html"><![CDATA[<p>本文一共介绍了七种方法：<br>一：最简单的加密解密<br>二：转义字符”\”的妙用<br>三：使用Microsoft出品的脚本编码器Script Encoder来进行编码<br>四：任意添加NUL空字符（十六进制00H）<br>五：无用内容混乱以及换行空格TAB大法<br>六：自写解密函数法<br>七：错误的利用<br><a id="more"></a></p>
<h2 id="1、最简单的加密"><a href="#1、最简单的加密" class="headerlink" title="1、最简单的加密"></a>1、最简单的加密</h2><p>escape() 编码<br>unescape() 解码<br>通过unescape()直接加密的代码不能直接运行，此时需要通过eval(codeString)方法<br>eval(codeString)，这个函数的作用就是检查JavaScript代码并执行，必选项 codeString 参数是包含有效 JavaScript 代码的字符串值，加上上面的解码unescape()，加密后的结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt;  </div><div class="line">    var code=unescape(<span class="string">"%61%6C%65%72%74%28%22%u9ED1%u5BA2%u9632%u7EBF%22%29%3B"</span>);  </div><div class="line">    <span class="built_in">eval</span>(code)  </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure></p>
<h2 id="2、转义字符”-”的妙用"><a href="#2、转义字符”-”的妙用" class="headerlink" title="2、转义字符”\”的妙用"></a>2、转义字符”\”的妙用</h2><p>JavaScript提供了一些特殊字符如：\n （换行）、 \r （回车）、\’ （单引号 ）等应该是有所了解的吧？其实”\”后面还可以跟八进制或十六进制的数字，如字符”a”则可以表示为：”\141”或”\x61”（注意是小写字符”x”），至于双字节字符如汉字”黑”则仅能用十六进制表示为”\u9ED1”（注意是小写字符”u”），其中字符”u”表示是双字节字符，根据这个原理例子代码则可以表示为：</p>
<h3 id="八进制转义字符串如下"><a href="#八进制转义字符串如下" class="headerlink" title="八进制转义字符串如下:"></a>八进制转义字符串如下:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt;  </div><div class="line">    <span class="built_in">eval</span>(<span class="string">"\141\154\145\162\164\50\42\u9ED1\u5BA2\u9632\u7EBF\42\51\73"</span>)  </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure>
<h3 id="十六进制转义字符串如下"><a href="#十六进制转义字符串如下" class="headerlink" title="十六进制转义字符串如下:"></a>十六进制转义字符串如下:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt;  </div><div class="line"><span class="built_in">eval</span>(<span class="string">"\x61\x6C\x65\x72\x74\x28\x22\u9ED1\u5BA2\u9632\u7EBF\x22\x29\x3B"</span>)  </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure>
<p>这次没有了解码函数，因为JavaScript执行时会自行转换，同样解码也是很简单如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt;  </div><div class="line">alert(<span class="string">"\x61\x6C\x65\x72\x74\x28\x22\u9ED1\u5BA2\u9632\u7EBF\x22\x29\x3B"</span>)  </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure></p>
<p>就会弹出对话框告诉你解密后的结果！ </p>
<h2 id="3、使用Microsoft出品的脚本编码器Script-Encoder来进行编码"><a href="#3、使用Microsoft出品的脚本编码器Script-Encoder来进行编码" class="headerlink" title="3、使用Microsoft出品的脚本编码器Script Encoder来进行编码"></a>3、使用Microsoft出品的脚本编码器Script Encoder来进行编码</h2><p>直接使用JavaScript调用控件Scripting.Encoder完成的编码！代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt;  </div><div class="line">    var Senc=new ActiveXObject(<span class="string">"Scripting.Encoder"</span>);  </div><div class="line">    var code=<span class="string">'&lt;SCRIPT LANGUAGE="JavaScript"&gt;\r\nalert("黑客防线");\r\n&lt;\/SCRIPT&gt;'</span>;  </div><div class="line">    var Encode=Senc.EncodeScriptFile(<span class="string">".htm"</span>,code,0,<span class="string">""</span>);  </div><div class="line">    alert(Encode);  </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure></p>
<p>编码后的结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JScript.Encode"</span>&gt;<span class="comment">#@~^FgAAAA==@#@&amp;ls DD`J黑客防线r#p@#@&amp;FgMAAA==^#~@&lt;/SCRIPT&gt;</span></div></pre></td></tr></table></figure></p>
<p>解密方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JScript.Encode"</span>&gt;  </div><div class="line">    <span class="keyword">function</span> decode()  </div><div class="line">    alert(decode.toString());  </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure></p>
<p>解密原理：<br>编码后的代码运行前IE会先对其进行解码，如果我们先把加密的代码放入一个自定义函数如上面的decode()中，然后对自定义函数decode调用toString()方法，得到的将是解码后的代码！<br>这样编码得到的代码LANGUAGE属性是JScript.Encode，很容易让人识破，那么还有一个几乎不为人知的window对象的方法execScript()，其原形为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.execScript( sExpression, sLanguage )</div></pre></td></tr></table></figure></p>
<p>参数：<br>　sExpression: 必选项。字符串(String)。要被执行的代码。<br>　sLanguage　: 必选项。字符串(String)。指定执行的代码的语言。默认值为 Microsoft JScript<br>使用时，前面的”window”可以省略不写！<br>利用它我们可以很好的运行编码后的JavaScript代码，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt;  </div><div class="line">    execScript(<span class="string">"#@~^FgAAAA==@#@&amp;ls DD`J黑客防线r#p@#@&amp;FgMAAA==^#~@"</span>,<span class="string">"JScript.Encode"</span>)  </div><div class="line">&lt;/SCRIPT&gt;</div><div class="line">``` </div><div class="line">可以利用方法二对其中的<span class="string">""</span>号内的字符串再进行编码，使得<span class="string">"JScript.Encode"</span>以及编码特征码<span class="string">"#@~^"</span>不出现，效果会更好！ </div><div class="line"><span class="comment">## 4、任意添加NUL空字符（十六进制00H） </span></div><div class="line">在HTML网页中任意位置添加任意个数的<span class="string">"空字符"</span>，IE照样会正常显示其中的内容，并正常执行其中的JavaScript 代码，而添加的<span class="string">"空字符"</span>在用一般的编辑器查看时，会显示形如空格或黑块，使得原码很难看懂，如用记事本查看则<span class="string">"空字符"</span>会变成<span class="string">"空格"</span>，利用这个原理加密结果如下：（其中显示的<span class="string">"空格"</span>代表<span class="string">"空字符"</span>） </div><div class="line"></div><div class="line">&lt;S    C    RI    P T L    ANG U    A        G E      </div><div class="line"></div><div class="line"> =<span class="string">"    J    a    v a S    c r    i p t "</span>&gt; </div><div class="line"></div><div class="line">a    l er    t    (<span class="string">" 黑    客 防 线"</span>)    ;    </div><div class="line">   </div><div class="line">&lt;    /    SC    R    I    P    T&gt;  </div><div class="line"><span class="comment">## 5、无用内容混乱以及换行空格TAB大法 </span></div><div class="line">在JAVASCRIPT代码中可以加入大量的无用字符串或数字，以及无用代码和注释内容等等，使真正的有用代码埋没在其中，并把有用的代码中能加入换行、空格、TAB的地方加入大量换行、空格、TAB，并可以把正常的字符串用<span class="string">""</span>来进行换行，这样就会使得代码难以看懂！加密后的形式如下： </div><div class="line">``` bash</div><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt;  </div><div class="line"><span class="string">"xajgxsadffgds"</span>;1234567890  </div><div class="line">625623216;var =0;alert//@%%&amp;*()(&amp;(^%^  </div><div class="line">//cctv <span class="keyword">function</span>//  </div><div class="line">(//hhsaasajx xc  </div><div class="line">/*  </div><div class="line">asjgdsgu*/  </div><div class="line"><span class="string">"黑 </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">客  </span></div><div class="line"><span class="string">防线"</span>//ashjgfgf  </div><div class="line">/*  </div><div class="line">@<span class="comment">#%^&amp;%96667r45fggbhytjty  </span></div><div class="line">*/  </div><div class="line">//window  </div><div class="line">)  </div><div class="line">;<span class="string">"#@<span class="variable">$#</span>%@#432hu"</span>;212351436  </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure></p>
<h2 id="6、自写解密函数法"><a href="#6、自写解密函数法" class="headerlink" title="6、自写解密函数法"></a>6、自写解密函数法</h2><p>这个方法和一、二差不多，只不过是自己写个函数对代码进行解密，很多VBS病毒使用这种方法对自身进行加密，来防止特征码扫描！下面是写的一个简单的加密解密函数，<br>加密代码如下（详细参照文件”加密.htm”）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt;  </div><div class="line">    <span class="keyword">function</span> compile(code)  </div><div class="line">    &#123;    </div><div class="line">       var c=String.fromCharCode(code.charCodeAt(0)+code.length);  </div><div class="line">       <span class="keyword">for</span>(var i=1;i&lt;code.length;i++)&#123;  </div><div class="line">       c+=String.fromCharCode(code.charCodeAt(i)+code.charCodeAt(i-1));  </div><div class="line">       &#125;  </div><div class="line">       alert(escape(c));  </div><div class="line">    &#125;  </div><div class="line">compile(’alert(<span class="string">"黑客防线"</span>);’)  </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure></p>
<p>运行得到加密结果为：o%CD%D1%D7%E6%9CJ%u9EF3%uFA73%uF1D4%u14F1%u7EE1Kd<br>相应的加密后解密的代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt;  </div><div class="line">    <span class="keyword">function</span> uncompile(code)  </div><div class="line">    &#123;  </div><div class="line">       code=unescape(code);  </div><div class="line">       var c=String.fromCharCode(code.charCodeAt(0)-code.length);  </div><div class="line">       <span class="keyword">for</span>(var i=1;i&lt;code.length;i++)&#123;  </div><div class="line">       c+=String.fromCharCode(code.charCodeAt(i)-c.charCodeAt(i-1));  </div><div class="line">       &#125;  </div><div class="line">       <span class="built_in">return</span> c;  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">eval</span>(uncompile(<span class="string">"o%CD%D1%D7%E6%9CJ%u9EF3%uFA73%uF1D4%u14F1%u7EE1Kd"</span>));  </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure></p>
<h2 id="7、错误的利用"><a href="#7、错误的利用" class="headerlink" title="7、错误的利用"></a>7、错误的利用</h2><p>利用try{}catch(e){}结构对代码进行测试解密，因为实用性不大<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt; </div><div class="line">    var a=’alert(<span class="string">"黑客防线"</span>);’;  </div><div class="line">    var c=<span class="string">""</span>;  </div><div class="line">    <span class="keyword">for</span>(var i=0;i&lt;a.length;i++)&#123;  </div><div class="line">    c+=String.fromCharCode(a.charCodeAt(i)^61);&#125; </div><div class="line">    alert(c); </div><div class="line"></div><div class="line">//上面的是加密代码，当然如果真正使用这个方法时，不会把加密写上的  </div><div class="line">//现在变量c就是加密后的代码 </div><div class="line"></div><div class="line">//下面的函数t()先假设初始密码为０，解密执行，  </div><div class="line">//遇到错误则把密码加１，然后接着解密执行，直到正确运行 </div><div class="line"></div><div class="line">    var d=c;    //保存加密后的代码  </div><div class="line">    var b=0;    //假定初始密码为0  </div><div class="line">    t(); </div><div class="line"></div><div class="line">    <span class="keyword">function</span> <span class="function"><span class="title">t</span></span>()&#123;</div><div class="line">        try&#123;<span class="built_in">eval</span>(c);&#125;</div><div class="line">        catch(e)&#123; </div><div class="line">            c=<span class="string">""</span>; </div><div class="line">            <span class="keyword">for</span>(var i=0;i&lt;d.length;i++)&#123; </div><div class="line">            c+=String.fromCharCode(d.charCodeAt(i)^b);&#125;</div><div class="line">            b+=1; </div><div class="line">            t();</div><div class="line">            //setTimeout(<span class="string">"t()"</span>,0); </div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文一共介绍了七种方法：&lt;br&gt;一：最简单的加密解密&lt;br&gt;二：转义字符”\”的妙用&lt;br&gt;三：使用Microsoft出品的脚本编码器Script Encoder来进行编码&lt;br&gt;四：任意添加NUL空字符（十六进制00H）&lt;br&gt;五：无用内容混乱以及换行空格TAB大法&lt;br&gt;六：自写解密函数法&lt;br&gt;七：错误的利用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="php" scheme="http://weibo.com/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>ThinkPHP多层MVC</title>
    <link href="http://weibo.com/2017/09/11/ThinkPHP%E5%A4%9A%E5%B1%82MVC/"/>
    <id>http://weibo.com/2017/09/11/ThinkPHP多层MVC/</id>
    <published>2017-09-11T01:08:08.000Z</published>
    <updated>2017-09-11T12:40:11.661Z</updated>
    
    <content type="html"><![CDATA[<p>ThinkPHP基于MVC（Model-View-Controller，模型-视图-控制器）模式，并且均支持多层（multi-Layer）设计。</p>
<h2 id="模型（Model）层"><a href="#模型（Model）层" class="headerlink" title="模型（Model）层"></a>模型（Model）层</h2><p>默认的模型层由Model类构成，但是随着项目的增大和业务体系的复杂化，单一的模型层很难解决要求，ThinkPHP支持多层Model，设计思路很简单，不同的模型层仍然都继承自系统的Model类，但是在目录结构和命名规范上做了区分。<br><a id="more"></a><br>例如在某个项目设计中需要区分数据层、逻辑层、服务层等不同的模型层，我们可以在模块目录下面创建Model、Logic和Service目录，把对用户表的所有模型操作分成三层：<br>1、数据层：Model/UserModel 用于定义数据相关的自动验证和自动完成和数据存取接口<br>2、逻辑层：Logic/UserLogic 用于定义用户相关的业务逻辑<br>3、服务层：Service/UserService 用于定义用户相关的服务接口等<br>而这三个模型操作类统一都继承Model类即可，例如：<br>数据层：Home/Model/UserModel.class.php<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">namespace Home\Model;</div><div class="line">use Think\Model;</div><div class="line">class UserModel extends Model&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>逻辑层：Home/Logic/UserLogic.class.php<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">namespace Home\Logic;</div><div class="line">use Think\Model;</div><div class="line">class UserLogic extends Model&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务层：Home/Service/UserService.class.php<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">namespace Home\Service;</div><div class="line">use Think\Model;</div><div class="line">class UserService extends Model&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样区分不同的模型层之后对用户数据的操作就非常清晰，在调用的时候，我们也可以用内置的D方法很方便的调用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">D(<span class="string">'User'</span>) //实例化UserModel</div><div class="line">D(<span class="string">'User'</span>,<span class="string">'Logic'</span>) //实例化UserLogic</div><div class="line">D(<span class="string">'User'</span>,<span class="string">'Service'</span>) //实例化UserService</div></pre></td></tr></table></figure></p>
<p>默认的模型层是Model，我们也可以更改设置，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'DEFAULT_M_LAYER'</span>       =&gt;  <span class="string">'Logic'</span>, // 更改默认的模型层名称为Logic</div></pre></td></tr></table></figure></p>
<p>更改之后，实例化的时候需要改成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">D(<span class="string">'User'</span>) //实例化UserLogic</div><div class="line">D(<span class="string">'User'</span>,<span class="string">'Model'</span>) //实例化UserModel</div><div class="line">D(<span class="string">'User'</span>,<span class="string">'Service'</span>) //实例化UserService</div></pre></td></tr></table></figure></p>
<p>对模型层的分层划分是很灵活的，开发人员可以根据项目的需要自由定义和增加模型分层，你也完全可以只使用Model层。</p>
<h2 id="视图（View）层"><a href="#视图（View）层" class="headerlink" title="视图（View）层"></a>视图（View）层</h2><p>视图层由模板和模板引擎组成，在模板中可以直接使用PHP代码，通过驱动也可以支持其他第三方的模板引擎。视图的多层可以简单的通过目录（也就是模板主题）区分，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">View/default/User/add.html</div><div class="line">View/blue/User/add.html</div></pre></td></tr></table></figure></p>
<p>复杂一点的多层视图还可以更进一步，采用不同的视图目录来完成，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">view 普通视图层目录</div><div class="line">mobile 手机端访问视图层目录</div></pre></td></tr></table></figure></p>
<p>这样做的好处是每个不同的视图层都可以支持不同的模板主题功能。<br>默认的视图层是View目录，我们可以调整设置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'DEFAULT_V_LAYER'</span>       =&gt;  <span class="string">'Mobile'</span>, // 默认的视图层名称更改为Mobile</div></pre></td></tr></table></figure></p>
<p>非默认视图层目录的模板获取需要使用T函数</p>
<h2 id="控制器（Controller）层"><a href="#控制器（Controller）层" class="headerlink" title="控制器（Controller）层"></a>控制器（Controller）层</h2><p>ThinkPHP的控制器层由核心控制器和业务控制器组成，核心控制器由系统内部的App类完成，负责应用（包括模块、控制器和操作）的调度控制，包括HTTP请求拦截和转发、加载配置等。业务控制器则由用户定义的控制器类完成。多层业务控制器的实现原理和模型的分层类似，例如业务控制器和事件控制器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Controller/UserController //用于用户的业务逻辑控制和调度</div><div class="line">Event/UserEvent //用于用户的事件响应操作</div></pre></td></tr></table></figure></p>
<p>访问控制器 Home/Controller/UserController.class.php 定义如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">namespace Home\Controller;</div><div class="line">use Think\Controller;</div><div class="line">class UserController extends Controller&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>事件控制器 Home/Event/UserEvent.class.php 定义如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">namespace Home\Event;</div><div class="line">use Think\Controller;</div><div class="line">class UserEvent extends Controller&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>UserController负责外部交互响应，通过URL请求响应，例如 <a href="http://serverName/User/index,而" target="_blank" rel="external">http://serverName/User/index,而</a> UserEvent负责内部的事件响应，并且只能在内部调用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A(<span class="string">'User'</span>,<span class="string">'Event'</span>);</div></pre></td></tr></table></figure></p>
<p>默认的访问控制器层是Controller，我们可以调整设置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'DEFAULT_C_LAYER'</span>       =&gt;  <span class="string">'Event'</span>, // 默认的控制器层名称改为Event</div></pre></td></tr></table></figure></p>
<p>所以是和外部隔离的。<br>多层控制器的划分也不是强制的，可以根据应用的需要自由分层。控制器分层里面可以根据需要调用分层模型，也可以调用不同的分层视图（主题）。<br>在MVC三层中，ThinkPHP并不依赖M或者V，甚至可以只有C或者只有V，这个在ThinkPHP的设计里面是一个很重要的用户体验设计，用户只需要定义视图，在没有C的情况下也能自动识别。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThinkPHP基于MVC（Model-View-Controller，模型-视图-控制器）模式，并且均支持多层（multi-Layer）设计。&lt;/p&gt;
&lt;h2 id=&quot;模型（Model）层&quot;&gt;&lt;a href=&quot;#模型（Model）层&quot; class=&quot;headerlink&quot; title=&quot;模型（Model）层&quot;&gt;&lt;/a&gt;模型（Model）层&lt;/h2&gt;&lt;p&gt;默认的模型层由Model类构成，但是随着项目的增大和业务体系的复杂化，单一的模型层很难解决要求，ThinkPHP支持多层Model，设计思路很简单，不同的模型层仍然都继承自系统的Model类，但是在目录结构和命名规范上做了区分。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编写shell脚本最佳实践</title>
    <link href="http://weibo.com/2017/09/10/%E7%BC%96%E5%86%99shell%E8%84%9A%E6%9C%AC%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://weibo.com/2017/09/10/编写shell脚本最佳实践/</id>
    <published>2017-09-10T06:47:35.000Z</published>
    <updated>2017-09-10T07:17:02.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码风格规范"><a href="#代码风格规范" class="headerlink" title="代码风格规范"></a>代码风格规范</h2><h3 id="开头有“蛇棒”"><a href="#开头有“蛇棒”" class="headerlink" title="开头有“蛇棒”"></a>开头有“蛇棒”</h3><p>所谓shebang其实就是在很多脚本的第一行出现的以”#!”开头的注释，他指明了当我们没有指定解释器的时候默认的解释器，一般可能是下面这样:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div></pre></td></tr></table></figure></p>
<p>当然，解释器有很多种，除了bash之外，我们可以用下面的命令查看本机支持的解释器:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/shells</div><div class="line"><span class="comment">#/etc/shells: valid login shells</span></div><div class="line">/bin/sh</div><div class="line">/bin/dash</div><div class="line">/bin/bash</div><div class="line">/bin/rbash</div><div class="line">/user/bin/screen</div></pre></td></tr></table></figure></p>
<p>当我们直接使用./a.sh来执行这个脚本的时候，如果没有shebang，那么它就会默认用$SHELL指定的解释器，否则就会用shebang指定的解释器。<br><a id="more"></a><br>不过，上面这种写法可能不太具备适应性，一般我们会用下面的方式来指定：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env bash</span></div></pre></td></tr></table></figure></p>
<p>这种方式是我们推荐的使用方式。</p>
<h3 id="代码有注释"><a href="#代码有注释" class="headerlink" title="代码有注释"></a>代码有注释</h3><p>注释，显然是一个常识，不过这里还是要再强调一下，这个在shell脚本里尤为重要。因为很多单行的shell命令不是那么浅显易懂，没有注释的话在维护起来会让人尤其的头大。<br>注释的意义不仅在于解释用途，而在于告诉我们注意事项，就像是一个README。<br>具体的来说，对于shell脚本，注释一般包括下面几个部分：<br>1、shebang<br>2、脚本的参数<br>3、脚本的用途<br>4、脚本的注意事项<br>5、脚本的写作时间，作者，版权等<br>6、各个函数前的说明注释<br>7、一些较复杂的单行命令注释</p>
<h3 id="参数要规范"><a href="#参数要规范" class="headerlink" title="参数要规范"></a>参数要规范</h3><p>这一点很重要，当我们的脚本需要接受参数的时候，我们一定要先判断参数是否合乎规范，并给出合适的回显，方便使用者了解参数的使用。<br>最少，最少，我们至少得判断下参数的个数吧：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [[ <span class="variable">$#</span> != 2 ]];<span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"Parameter incorrect."</span></div><div class="line">    <span class="built_in">exit</span> 1</div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure></p>
<h3 id="变量和魔数"><a href="#变量和魔数" class="headerlink" title="变量和魔数"></a>变量和魔数</h3><p>一般情况下我们会将一些重要的环境变量定义在开头，确保这些变量的存在。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> /etc/profile</div><div class="line"><span class="built_in">export</span> PATH=”/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/<span class="built_in">local</span>/sbin:/usr/sbin:/sbin:/apps/bin/”</div></pre></td></tr></table></figure></p>
<p>这种定义方式有一个很常见的用途，最典型的应用就是，当我们本地安装了很多java版本时，我们可能需要指定一个java来用。那么这时我们就会在脚本开头重新定义JAVA_HOME以及PATH变量来进行控制。<br>同时，一段好的代码通常是不会有很多硬编码在代码里的“魔数”的。如果一定要有，通常是用一个变量的形式定义在开头，然后调用的时候直接调用这个变量，这样方便日后的修改。</p>
<h3 id="缩进有规矩"><a href="#缩进有规矩" class="headerlink" title="缩进有规矩"></a>缩进有规矩</h3><p>对于shell脚本，缩进是个大问题。因为很多需要缩进的地方(比如if,for语句)都不长，所有很多人都懒得去缩进，而且很多人不习惯用函数，导致缩进功能被弱化。<br>其实正确的缩进是很重要的，尤其是在写函数的时候，否则我们在阅读的时候很容易把函数体跟直接执行的命令搞混。<br>常见的缩进方法主要有”soft tab”和”hard tab”两种。<br>1、所谓soft tab就是使用n个空格进行缩进(n通常是2或4)<br>2、所谓hard tab当然就是指真实的”\t”字符<br>这里不去撕哪种方式最好，只能说各有各的优劣。反正我习惯用hard tab。<br>对于if和for语句之类的，我们最好不要把then，do这些关键字单独写一行，这样看上去比较丑。。。</p>
<h3 id="命名有标准"><a href="#命名有标准" class="headerlink" title="命名有标准"></a>命名有标准</h3><p>所谓命名规范，基本包含下面这几点：<br>1、文件名规范，以.sh结尾，方便识别<br>2、变量名字要有含义，不要拼错<br>3、统一命名风格，写shell一般用小写字母加下划线</p>
<h3 id="编码要统一"><a href="#编码要统一" class="headerlink" title="编码要统一"></a>编码要统一</h3><p>在写脚本的时候尽量使用UTF-8编码，能够支持中文等一些奇奇怪怪的字符。不过虽然能写中文，但是在写注释以及打log的时候还是尽量英文，毕竟很多机器还是没有直接支持中文的，打出来可能会有乱码。</p>
<h3 id="权限记得加"><a href="#权限记得加" class="headerlink" title="权限记得加"></a>权限记得加</h3><p>这一点虽然很小，但是我个人却经常忘记，不加执行权限会导致无法直接执行，有点讨厌</p>
<h3 id="日志和回显"><a href="#日志和回显" class="headerlink" title="日志和回显"></a>日志和回显</h3><p>日志的重要性不必多说，能够方便我们回头纠错，在大型的项目里是非常重要的。<br>如果这个脚本是供用户直接在命令行使用的，那么我们最好还要能够在执行时实时回显执行过程，方便用户掌控。</p>
<h3 id="密码要移除"><a href="#密码要移除" class="headerlink" title="密码要移除"></a>密码要移除</h3><p>不要把密码硬编码在脚本里，不要把密码硬编码在脚本里，不要把密码硬编码在脚本里。<br>重要的事情说三遍，尤其是当脚本托管在类似Github这类平台中时</p>
<h3 id="太长要分行"><a href="#太长要分行" class="headerlink" title="太长要分行"></a>太长要分行</h3><p>在调用某些程序的时候，参数可能会很长，这时候为了保证较好的阅读体验，我们可以用反斜杠来分行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./configure \</div><div class="line">–prefix=/usr \</div><div class="line">–sbin-path=/usr/sbin/nginx \</div><div class="line">–conf-path=/etc/nginx/nginx.conf \</div></pre></td></tr></table></figure></p>
<p>注意在反斜杠前有个空格。</p>
<h2 id="编码细节规范"><a href="#编码细节规范" class="headerlink" title="编码细节规范"></a>编码细节规范</h2><h3 id="代码有效率"><a href="#代码有效率" class="headerlink" title="代码有效率"></a>代码有效率</h3><p>在使用命令的时候要了解命令的具体做法，尤其当数据处理量大的时候，要时刻考虑该命令是否会影响效率。<br>比如下面的两个sed命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="string">'1p'</span> file</div><div class="line">sed -n <span class="string">'1p;1q'</span> file</div></pre></td></tr></table></figure></p>
<p>他们的作用一样，都是获取文件的第一行。但是第一条命令会读取整个文件，而第二条命令只读取第一行。当文件很大的时候，仅仅是这样一条命令不一样就会造成巨大的效率差异。<br>当然，这里只是为了举一个例子，这个例子真正正确的用法应该是使用head -n1 file命令</p>
<h3 id="勤用双引号"><a href="#勤用双引号" class="headerlink" title="勤用双引号"></a>勤用双引号</h3><p>几乎所有的大佬都推荐在使用”$”来获取变量的时候最好加上双引号。<br>不加上双引号在很多情况下都会造成很大的麻烦，为什么呢？举一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="comment">#已知当前文件夹有一个a.sh的文件</span></div><div class="line">var=<span class="string">"*.sh"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$var</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></div></pre></td></tr></table></figure></p>
<p>他的运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a.sh</div><div class="line">*.sh</div></pre></td></tr></table></figure></p>
<p>为啥会这样呢？其实可以解释为它执行了下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> *.sh</div><div class="line"><span class="built_in">echo</span> <span class="string">"*.sh"</span></div></pre></td></tr></table></figure></p>
<p>在很多情况下，在将变量作为参数的时候，一定要注意上面这一点，仔细体会其中的差异。上面只是一个非常小的例子，实际应用的时候由于这个细节导致的问题实在是太多了</p>
<h3 id="巧用main函数"><a href="#巧用main函数" class="headerlink" title="巧用main函数"></a>巧用main函数</h3><p>我们知道，像java，C这样的编译型语言都会有一个函数入口，这种结构使得代码可读性很强，我们知道哪些直接执行，那些是函数。但是脚本不一样，脚本属于解释性语言，从第一行直接执行到最后一行，如果在这当中命令与函数糅杂在一起，那就非常难读了。<br>用python的朋友都知道，一个合乎标准的python脚本大体上至少是这样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line">def func1():</div><div class="line">    pass</div><div class="line">def func2():</div><div class="line">    pass</div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    func1()</div><div class="line">    func2()</div></pre></td></tr></table></figure></p>
<p>他用一个很巧妙的方法实现了我们习惯的main函数，使得代码可读性更强。<br>在shell中，我们也有类似的小技巧:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env bash</span></div><div class="line"><span class="function"><span class="title">func1</span></span>()&#123;</div><div class="line">    <span class="comment">#do sth</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">func2</span></span>()&#123;</div><div class="line">    <span class="comment">#do sth</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">main</span></span>()&#123;</div><div class="line">    func1</div><div class="line">    func2</div><div class="line">&#125;</div><div class="line">main <span class="string">"<span class="variable">$@</span>"</span></div></pre></td></tr></table></figure></p>
<p>我们可以采用这种写法，同样实现类似的main函数，使得脚本的结构化程度更好。</p>
<h3 id="考虑作用域"><a href="#考虑作用域" class="headerlink" title="考虑作用域"></a>考虑作用域</h3><p>shell中默认的变量作用域都是全局的，比如下面的脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env bash</span></div><div class="line">var=1</div><div class="line"><span class="function"><span class="title">func</span></span>()&#123;</div><div class="line">    var=2</div><div class="line">&#125;</div><div class="line">func</div><div class="line"><span class="built_in">echo</span> <span class="variable">$var</span></div></pre></td></tr></table></figure></p>
<p>他的输出结果就是2而不是1，这样显然不符合我们的编码习惯，很容易造成一些问题。<br>因此，相比直接使用全局变量，我们最好使用local readonly这类的命令，其次我们可以使用declare来声明变量。这些方式都比使用全局方式定义要好。</p>
<h3 id="巧用heredocs"><a href="#巧用heredocs" class="headerlink" title="巧用heredocs"></a>巧用heredocs</h3><p>所谓heredocs，也可以算是一种多行输入的方法，即在”&lt;&lt;”后定一个标识符，接着我们可以输入多行内容，直到再次遇到标识符为止。<br>使用heredocs，我们可以非常方便的生成一些模板文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat&gt;&gt;/etc/rsyncd.conf &lt;&lt; EOF</div><div class="line"><span class="built_in">log</span> file = /usr/<span class="built_in">local</span>/logs/rsyncd.log</div><div class="line">transfer logging = yes</div><div class="line"><span class="built_in">log</span> format = %t %a %m %f %b</div><div class="line">syslog facility = local3</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<h3 id="学会查路径"><a href="#学会查路径" class="headerlink" title="学会查路径"></a>学会查路径</h3><p>很多情况下，我们会先获取当前脚本的路径，然后一这个路径为基准，去找其他的路径。通常我们是直接用pwd以期获得脚本的路径。<br>不过其实这样是不严谨的，pwd获得的是当前shell的执行路径，而不是当前脚本的执行路径。<br>正确的做法应该是下面这两种：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">script_dir=$(<span class="built_in">cd</span> $(dirname <span class="variable">$0</span>) &amp;&amp; <span class="built_in">pwd</span>)</div><div class="line">script_dir=$(dirname $(readlink -f <span class="variable">$0</span> ))</div></pre></td></tr></table></figure></p>
<p>应当先cd进当前脚本的目录然后再pwd，或者直接读取当前脚本的所在路径。</p>
<h3 id="代码要简短"><a href="#代码要简短" class="headerlink" title="代码要简短"></a>代码要简短</h3><p>这里的简短不单单是指代码长度，而是只用到的命令数。原则上我们应当做到，能一条命令解决的问题绝不用两条命令解决。这不仅牵涉到代码的可读性，而且也关乎代码的执行效率。<br>最最经典的例子如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /etc/passwd | grep root</div><div class="line">grep root /etc/passwd</div></pre></td></tr></table></figure></p>
<p>cat命令最为人不齿的用法就是这样，用的没有任何意义，明明一条命令可以解决，他非得加根管道</p>
<h3 id="使用新写法"><a href="#使用新写法" class="headerlink" title="使用新写法"></a>使用新写法</h3><p>这里的新写法不是指有多厉害，而是指我们可能更希望使用较新引入的一些语法，更多是偏向代码风格的，比如<br>1、尽量使用func(){}来定义函数，而不是func{}<br>2、尽量使用[[]]来代替[]<br>3、尽量使用$()将命令的结果赋给变量，而不是反引号<br>4、在复杂的场景下尽量使用printf代替echo进行回显<br>事实上，这些新写法很多功能都比旧的写法要强大，用的时候就知道了。</p>
<h3 id="其他小tip"><a href="#其他小tip" class="headerlink" title="其他小tip"></a>其他小tip</h3><p>考虑到还有很多零碎的点，就不一一展开了，这里简单提一提。<br>路径尽量保持绝对路径，绝多路径不容易出错，如果非要用相对路径，最好用./修饰<br>优先使用bash的变量替换代替awk sed，这样更加简短<br>简单的if尽量使用&amp;&amp; ||，写成单行。比如[[ x &gt; 2]] &amp;&amp; echo x<br>当export变量时，尽量加上子脚本的namespace，保证变量不冲突<br>会使用trap捕获信号，并在接受到终止信号时执行一些收尾工作<br>使用mktemp生成临时文件或文件夹<br>利用/dev/null过滤不友好的输出信息<br>会利用命令的返回值判断命令的执行情况<br>使用文件前要判断文件是否存在，否则做好异常处理<br>不要处理ls后的数据(比如ls -l | awk ‘{ print $8 }’)，ls的结果非常不确定，并且平台有关<br>读取文件时不要使用for loop而要使用while read</p>
<h2 id="静态检查工具shellcheck"><a href="#静态检查工具shellcheck" class="headerlink" title="静态检查工具shellcheck"></a>静态检查工具shellcheck</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>为了从制度上保证脚本的质量，我们最简单的想法大概就是搞一个静态检查工具，通过引入工具来弥补开发者可能存在的知识盲点。<br>市面上对于shell的静态检查工具还真不多，找来找去就找到一个叫shellcheck的工具，开源在github上，有8K多的star，看上去还是十分靠谱的。我们可以去他的主页了解具体的安装和使用信息。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这个工具的对不同平台的支持力度都很大，他至少支持了Debian,Arch,Gentoo,EPEL,Fedora,OS X,openSUSE等等各种的平台的主流包管理工具。安装方便。具体可以参照安装文档</p>
<h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>既然是静态检查工具，就一定可以集成在CI框架里，shellcheck可以非常方便的集成在Travis CI中，供以shell脚本为主语言的项目进行静态检查。</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>在文档的Gallery of bad code里，也提供了非常详细的“坏代码”的标准，具有非常不错的参考价值，可以在闲下来的时候当成”Java Puzzlers“之类的书来读读还是很惬意的。</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>不过，其实我觉得这个项目最最精华的部分都不是上面的功能，而是他提供了一个非常非常强大的wiki。在这个wiki里，我们可以找到这个工具所有判断的依据。在这里，每一个检测到的问题都可以在wiki里找到对应的问题单号，他不仅告诉我们”这样写不好”，而且告诉我们”为什么这样写不好”，”我们应当怎么写才好”，非常适合刨根问底党进一步研究。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码风格规范&quot;&gt;&lt;a href=&quot;#代码风格规范&quot; class=&quot;headerlink&quot; title=&quot;代码风格规范&quot;&gt;&lt;/a&gt;代码风格规范&lt;/h2&gt;&lt;h3 id=&quot;开头有“蛇棒”&quot;&gt;&lt;a href=&quot;#开头有“蛇棒”&quot; class=&quot;headerlink&quot; title=&quot;开头有“蛇棒”&quot;&gt;&lt;/a&gt;开头有“蛇棒”&lt;/h3&gt;&lt;p&gt;所谓shebang其实就是在很多脚本的第一行出现的以”#!”开头的注释，他指明了当我们没有指定解释器的时候默认的解释器，一般可能是下面这样:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#!/bin/bash&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然，解释器有很多种，除了bash之外，我们可以用下面的命令查看本机支持的解释器:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ cat /etc/shells&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#/etc/shells: valid login shells&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/bin/sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/bin/dash&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/bin/bash&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/bin/rbash&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/user/bin/screen&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当我们直接使用./a.sh来执行这个脚本的时候，如果没有shebang，那么它就会默认用$SHELL指定的解释器，否则就会用shebang指定的解释器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>S.O.L.I.D 原则</title>
    <link href="http://weibo.com/2017/09/10/S-O-L-I-D-%E5%8E%9F%E5%88%99/"/>
    <id>http://weibo.com/2017/09/10/S-O-L-I-D-原则/</id>
    <published>2017-09-10T05:57:20.000Z</published>
    <updated>2017-09-10T06:15:57.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单一责任原则-SRP"><a href="#单一责任原则-SRP" class="headerlink" title="单一责任原则(SRP)"></a>单一责任原则(SRP)</h2><p>当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。</p>
<h2 id="开放封闭原则-OCP"><a href="#开放封闭原则-OCP" class="headerlink" title="开放封闭原则(OCP)"></a>开放封闭原则(OCP)</h2><p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。<br>(1)通过增加代码来扩展功能，而不是修改已经存在的代码。<br>(2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。<br>(3)OCP支持替换的服务，而不用修改客户模块。<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public boolean sendByEmail(String addr, String title, String content) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">public boolean sendBySMS(String addr, String content) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">// 在其它地方调用上述方法发送信息</div><div class="line">sendByEmail(addr, title, content);</div><div class="line">sendBySMS(addr, content);</div></pre></td></tr></table></figure></p>
<p>如果现在又多了一种发送信息的方式，比如可以通过QQ发送信息，那么不仅需要增加一个方法sendByQQ()，还需要在调用它的地方进行修改，违反了OCP原则，更好的方式是<br>抽象出一个Send接口，里面有个send()方法，然后让SendByEmail和SendBySMS去实现它既可。这样即使多了一个通过QQ发送的请求，那么只要再添加一个SendByQQ实现类实现Send接口既可。这样就不需要修改已有的接口定义和已实现类，很好的遵循了OCP原则。</p>
<h2 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则(LSP)"></a>里氏替换原则(LSP)</h2><p>子类必须能够用来当作基类使用。如果类A继承类B，任何能使用A的地方，B也同样可以使用。例如，是否还记得，正方形可以看作是矩形！当进行扩展时：前提条件不许绕过，后置条件不能放宽限制，可见常量不能被修改(?)。常量：在扩展之前或之后，用户都需要依靠这个常量来传递信息。正确的使用set形式的继承关系。不遵守set语义是非常危险的。归纳：使用超类的引用的任何上下文中也可以使用其子类的引用替代。这个原则极大的限制了在纯扩展(继承)机制里可以做的事情。不遵守会带来风险。</p>
<h2 id="接口分离原则-ISP"><a href="#接口分离原则-ISP" class="headerlink" title="接口分离原则(ISP)"></a>接口分离原则(ISP)</h2><p>一个类对另一个类的依赖应该限制在最小化的接口上。</p>
<h2 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则(DIP)"></a>依赖倒置原则(DIP)</h2><p>1、高层模块不应该依赖于低层模块，二者都应该依赖于抽象<br>2.、抽象不应该依赖于细节，细节应该依赖于抽象<br>这个设计原则的亮点在于任何被DI框架注入的类很容易用mock对象进行测试和维护，因为对象创建代码集中在框架中，客户端代码也不混乱。有很多方式可以实现依赖倒置，比如像AspectJ等的AOP（Aspect Oriented programming）框架使用的字节码技术，或Spring框架使用的代理等。<br>(1).高层模块不要依赖低层模块；<br>(2).高层和低层模块都要依赖于抽象；<br>(3).抽象不要依赖于具体实现；<br>(4).具体实现要依赖于抽象；<br>(5).抽象和接口使模块之间的依赖分离。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1、一个对象只承担一种责任，所有服务接口只通过它来执行这种任务。<br>2、程序实体，比如类和对象，向扩展行为开放，向修改行为关闭。<br>3、子类应该可以用来替代它所继承的类。<br>4、一个类对另一个类的依赖应该限制在最小化的接口上。<br>5、依赖抽象层(接口)，而不是具体类。</p>
<h2 id="其它重要原则"><a href="#其它重要原则" class="headerlink" title="其它重要原则"></a>其它重要原则</h2><h3 id="Demeter定律"><a href="#Demeter定律" class="headerlink" title="Demeter定律"></a>Demeter定律</h3><p>也被称做封锁信息原则：只跟朋友交流<br>一个对象O的任何一个方法M只能调用下列类型的对象的方法：<br>1、它自己<br>2、它的参量<br>3、它创建/实例化的对象<br>4、它的直接组件对象</p>
<h3 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h3><p>不要调用我，我会调用你的。</p>
<h3 id="不要自我重复-DRY"><a href="#不要自我重复-DRY" class="headerlink" title="不要自我重复(DRY)"></a>不要自我重复(DRY)</h3><p>去掉重复代码。</p>
<h3 id="对接口编程，而不是对实现"><a href="#对接口编程，而不是对实现" class="headerlink" title="对接口编程，而不是对实现"></a>对接口编程，而不是对实现</h3><p>反向依赖的另外一种说法。</p>
<h3 id="你不需要它-YAGNI"><a href="#你不需要它-YAGNI" class="headerlink" title="你不需要它(YAGNI)"></a>你不需要它(YAGNI)</h3><p>不要添加你“认为以后可能有用”的代码。只在“事到临头”时才添加代码。</p>
<h3 id="简单化，傻瓜化-KISS"><a href="#简单化，傻瓜化-KISS" class="headerlink" title="简单化，傻瓜化(KISS)"></a>简单化，傻瓜化(KISS)</h3><p>让它能工作的最简单的方法是什么</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单一责任原则-SRP&quot;&gt;&lt;a href=&quot;#单一责任原则-SRP&quot; class=&quot;headerlink&quot; title=&quot;单一责任原则(SRP)&quot;&gt;&lt;/a&gt;单一责任原则(SRP)&lt;/h2&gt;&lt;p&gt;当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。&lt;/p&gt;
&lt;h2 id=&quot;开放封闭原则-OCP&quot;&gt;&lt;a href=&quot;#开放封闭原则-OCP&quot; class=&quot;headerlink&quot; title=&quot;开放封闭原则(OCP)&quot;&gt;&lt;/a&gt;开放封闭原则(OCP)&lt;/h2&gt;&lt;p&gt;软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。&lt;br&gt;(1)通过增加代码来扩展功能，而不是修改已经存在的代码。&lt;br&gt;(2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。&lt;br&gt;(3)OCP支持替换的服务，而不用修改客户模块。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SOLID" scheme="http://weibo.com/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>gulp</title>
    <link href="http://weibo.com/2017/09/10/gulp/"/>
    <id>http://weibo.com/2017/09/10/gulp/</id>
    <published>2017-09-10T01:41:35.000Z</published>
    <updated>2017-09-10T07:23:23.084Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间开发进度紧，没时间更新博客；<br>今天主要讲一下前端工程化构建工具–gulp和模块化管理工具–webpack。</p>
<h2 id="gulp是一个基于流的构建工具，可以自动执行指定的任务，简洁且高效"><a href="#gulp是一个基于流的构建工具，可以自动执行指定的任务，简洁且高效" class="headerlink" title="gulp是一个基于流的构建工具，可以自动执行指定的任务，简洁且高效"></a>gulp是一个基于流的构建工具，可以自动执行指定的任务，简洁且高效</h2><h2 id="gulp能干什么？"><a href="#gulp能干什么？" class="headerlink" title="gulp能干什么？"></a>gulp能干什么？</h2><p>1、开发环境下，想要能够按模块组织代码，监听实时变化<br>2、css/js预编译，postcss等方案，浏览器前缀自动补全等<br>3、条件输出不同的网页，比如app页面和mobile页面<br>4、线上环境下，我想要合并、压缩 html/css/javascritp/图片，减少网络请求，同时降低网络负担<br>5、等等…<br><a id="more"></a></p>
<h2 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g gulp    //全局安装</div><div class="line">npm install --save-dev gulp    //安装到当前项目并在package.json中添加依赖</div></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="gulp-task-task-name-deps-fn"><a href="#gulp-task-task-name-deps-fn" class="headerlink" title="gulp.task()   task(name[, deps], fn)"></a>gulp.task()   task(name[, deps], fn)</h3><p>task()方法用于定义任务，传入名字、依赖任务数组、函数即可，gulp会先执行任务数组，结束后调用定义的函数，可以通过此手段控制任务的执行顺利。<br>例：要定义一个任务build来执行css、js、imgs这三个任务，我们可以通过指定一个任务数组而不是函数来完成。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'build'</span>, [<span class="string">'css'</span>, <span class="string">'js'</span>, <span class="string">'imgs'</span>]);</div></pre></td></tr></table></figure></p>
<h3 id="gulp-src-src-globs-options"><a href="#gulp-src-src-globs-options" class="headerlink" title="gulp.src    src(globs[, options])"></a>gulp.src    src(globs[, options])</h3><p>src()方法输入一个glob或者glob数组，然后返回一个可以传递给插件的数据流<br>Gulp使用node-glob来从你指定的glob里面获取文件：<br>1、app.js 精确匹配<br>2、<em>.js 能匹配js后缀的文件<br>3、**/</em>.js 能匹配多级目录下的js文件（也包含当前目录下）<br>4、!js/app.js 精确排除<br>例：js目录下包含了压缩和未压缩的js文件，我们想要压缩还没有被压缩的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp.src([<span class="string">'js/**/*.js'</span>, <span class="string">'!js/**/*.min.js'</span>])</div></pre></td></tr></table></figure></p>
<h3 id="gulp-dest-dest-path-options"><a href="#gulp-dest-dest-path-options" class="headerlink" title="gulp.dest    dest(path[, options])"></a>gulp.dest    dest(path[, options])</h3><p>dest()方法用来写文件，第一个参数表示最终输出的目录名。注意，它无法允许我们指明最终输出的文件名，只能指定输出文件夹名，而且在文件夹不存在的情况下会自动创建。<br>例：把开发目录src下的js文件输出到部署目录dist下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gulp.src(<span class="string">'src/**/*.js'</span>)</div><div class="line">  .pipe(gulp.dest(<span class="string">'dist'</span>))</div></pre></td></tr></table></figure></p>
<h3 id="gulp-watch-watch-globs-opts-cb-or-watch-globs-opts-tasks"><a href="#gulp-watch-watch-globs-opts-cb-or-watch-globs-opts-tasks" class="headerlink" title="gulp.watch    watch(globs[, opts], cb) or watch(globs[, opts], tasks)"></a>gulp.watch    watch(globs[, opts], cb) or watch(globs[, opts], tasks)</h3><p>watch()方法可以监听文件，它接受一个glob或者glob数组以及一个任务数组来执行回调<br>// 当templates目录下的模板文件发生变化，自动执行编译任务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'watch'</span>, <span class="keyword">function</span> (event) &#123;</div><div class="line">  gulp.watch(<span class="string">'templates/*.tmpl.html'</span>, [<span class="string">'artTemplate'</span>]);</div><div class="line">  console.log(<span class="string">'Event type: '</span> + event.type); // added, changed, or deleted   </div><div class="line">  console.log(<span class="string">'Event path: '</span> + event.path); // The path of the modified file</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="gulp-watch-的另一个非常好的特性是返回watcher对象"><a href="#gulp-watch-的另一个非常好的特性是返回watcher对象" class="headerlink" title="gulp.watch()的另一个非常好的特性是返回watcher对象"></a>gulp.watch()的另一个非常好的特性是返回watcher对象</h3><h4 id="watcher对象可以监听很多事件"><a href="#watcher对象可以监听很多事件" class="headerlink" title="watcher对象可以监听很多事件:"></a>watcher对象可以监听很多事件:</h4><p>change 文件变化时触发<br>end 在watcher结束时触发<br>error 在出现error时触发<br>ready 在文件被找到并正被监听时触发<br>nomatch 在glob没有匹配到任何文件时触发</p>
<h4 id="Watcher对象也包含了一些可以调用的方法："><a href="#Watcher对象也包含了一些可以调用的方法：" class="headerlink" title="Watcher对象也包含了一些可以调用的方法："></a>Watcher对象也包含了一些可以调用的方法：</h4><p>watcher.end() 停止watcher<br>watcher.files() 返回watcher监听的文件列表<br>watcher.add(glob) 将与指定glob相匹配的文件添加到watcher（也接受可选的回调当第二个参数）<br>watcher.remove(filepath) 从watcher中移除个别文件</p>
<h2 id="配置文件-gulpfile-js"><a href="#配置文件-gulpfile-js" class="headerlink" title="配置文件 gulpfile.js"></a>配置文件 gulpfile.js</h2><p><img src="/2017/09/10/gulp/gulp.png" alt=""><br>任务会让所有的文件匹配js/*.js，并且执行JSHint，然后打印输出结果，取消文件缩进，最后把他们合并起来，保存为build/app.js，整个过程如下图所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var gulp = require(<span class="string">'gulp'</span>),</div><div class="line">    jshint = require(<span class="string">'gulp-jshint'</span>),</div><div class="line">    uglify = require(<span class="string">'gulp-uglify'</span>),</div><div class="line">    concat = require(<span class="string">'gulp-concat'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">   <span class="built_in">return</span> gulp.src(<span class="string">'js/*.js'</span>)</div><div class="line">      .pipe(jshint())</div><div class="line">      .pipe(jshint.reporter(<span class="string">'default'</span>))</div><div class="line">      .pipe(uglify())</div><div class="line">      .pipe(concat(<span class="string">'app.js'</span>))</div><div class="line">      .pipe(gulp.dest(<span class="string">'build'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、按需打包、按需加载等。"><a href="#webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、按需打包、按需加载等。" class="headerlink" title="webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、按需打包、按需加载等。"></a>webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、按需打包、按需加载等。</h2><h2 id="webpack-重要特征"><a href="#webpack-重要特征" class="headerlink" title="webpack 重要特征"></a>webpack 重要特征</h2><p>1、插件化：<br>webpack本身非常灵活，提供了丰富的插件接口。基于这些接口，webpack开发了很多插件作为内置功能。<br>2、速度快：<br>webpack使用异步IO以及多级缓存机制。所以webpack的速度是很快的，尤其是增量更新。<br>丰富的Loaders：<br>loaders用来对文件做预处理。这样webpack就可以打包任何静态文件。<br>3、高适配性：<br>webpack同时支持AMD/CommonJs/ES6模块方案。webpack会静态解析你的代码，自动帮你管理他们的依赖关系。此外，webpack对第三方库的兼容性很好。<br>4、代码拆分：<br>webpack可以将你的代码分片，从而实现按需打包。这种机制可以保证页面只加载需要的JS代码，减少首次请求的时间。<br>5、优化：<br>webpack提供了很多优化机制来减少打包输出的文件大小，不仅如此，它还提供了hash机制，来解决浏览器缓存问题。<br>6、开发模式友好：<br>webpack为开发模式也提供了很多辅助功能。比如SourceMap、热更新等。<br>7、使用场景多：<br>webpack不仅适用于web应用场景，也适用于Webworkers、Node.js场景</p>
<h2 id="webpack-最佳配置"><a href="#webpack-最佳配置" class="headerlink" title="webpack 最佳配置"></a>webpack 最佳配置</h2><p>比如要解决：production模式和development模式，webpack的配置是有差异的，大致有两种思路。<br>1、两份配置文件webpack.config.production.js/webpack.config.development.js，然后不同场景下，使用不同的配置文件。<br>2、通过module.exports返回函数，该函数能接受参数。<br>相对来说，第一种更简单，但是重复配置多；第二种更灵活，推荐第二种方式。<br>那么，按返回函数的方式的配置代码架子如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">module.exports = <span class="keyword">function</span>(env) &#123;</div><div class="line">    <span class="built_in">return</span> &#123;</div><div class="line">        context: config.context,</div><div class="line">        entry: config.src,</div><div class="line">        output: &#123;</div><div class="line">            path: path.join(config.jsDest, project),</div><div class="line">            filename: <span class="string">'[name].js'</span>,</div><div class="line">            chunkFilename: <span class="string">'[name].[chunkhash:8].js'</span>,</div><div class="line">            publicPath: <span class="string">'/assets/'</span> + project + <span class="string">'/'</span></div><div class="line">        &#125;,</div><div class="line">        devtool: <span class="string">"eval"</span>,</div><div class="line">        watch: <span class="literal">false</span>,</div><div class="line">        profile: <span class="literal">true</span>,</div><div class="line">        cache: <span class="literal">true</span>,</div><div class="line">        module: &#123;</div><div class="line">            loaders: getLoaders(env)</div><div class="line">        &#125;,</div><div class="line">        resolve: &#123;</div><div class="line">            <span class="built_in">alias</span>: getAlias(env)</div><div class="line">        &#125;,</div><div class="line">        plugins: getPlugins(env)</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中关键的配置这儿简单介绍如下，后续的系列博客会根据每个点详细介绍。<br>context：上下文。<br>entry：入口文件，是所有依赖关系的入口，webpack从这个入口开始静态解析，分析模块之间的依赖关系。<br>output：打包输出的配置。<br>devtools：SourceMap选项，便于开发模式下调试。<br>watch：监听模式，增量更新，开发必备！<br>profile：优化。<br>cache：webpack构建的过程中会生成很多临时的文件，打开cache可以让这些临时的文件缓存起来，从而更快的构建。<br>module.loaders：如前文介绍，loaders用来对文件做预处理。这样webpack就可以打包任何静态文件。<br>resolve.alias：模块别名，这样可以更方便的引用模块。<br>plugins：如前文介绍，webpack的一些内置功能均是以插件的形式提供。</p>
<h2 id="webpack和gulp的区别"><a href="#webpack和gulp的区别" class="headerlink" title="webpack和gulp的区别"></a>webpack和gulp的区别</h2><p>gulp是基于流的构建工具：all in one的打包模式，输出一个js文件和一个css文件，优点是减少http请求，万金油方案。<br>webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、打包、按需加载等</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间开发进度紧，没时间更新博客；&lt;br&gt;今天主要讲一下前端工程化构建工具–gulp和模块化管理工具–webpack。&lt;/p&gt;
&lt;h2 id=&quot;gulp是一个基于流的构建工具，可以自动执行指定的任务，简洁且高效&quot;&gt;&lt;a href=&quot;#gulp是一个基于流的构建工具，可以自动执行指定的任务，简洁且高效&quot; class=&quot;headerlink&quot; title=&quot;gulp是一个基于流的构建工具，可以自动执行指定的任务，简洁且高效&quot;&gt;&lt;/a&gt;gulp是一个基于流的构建工具，可以自动执行指定的任务，简洁且高效&lt;/h2&gt;&lt;h2 id=&quot;gulp能干什么？&quot;&gt;&lt;a href=&quot;#gulp能干什么？&quot; class=&quot;headerlink&quot; title=&quot;gulp能干什么？&quot;&gt;&lt;/a&gt;gulp能干什么？&lt;/h2&gt;&lt;p&gt;1、开发环境下，想要能够按模块组织代码，监听实时变化&lt;br&gt;2、css/js预编译，postcss等方案，浏览器前缀自动补全等&lt;br&gt;3、条件输出不同的网页，比如app页面和mobile页面&lt;br&gt;4、线上环境下，我想要合并、压缩 html/css/javascritp/图片，减少网络请求，同时降低网络负担&lt;br&gt;5、等等…&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="gulp, webpack" scheme="http://weibo.com/tags/gulp-webpack/"/>
    
  </entry>
  
  <entry>
    <title>python实现简单爬虫</title>
    <link href="http://weibo.com/2017/08/29/python%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"/>
    <id>http://weibo.com/2017/08/29/python实现简单爬虫/</id>
    <published>2017-08-29T01:29:00.000Z</published>
    <updated>2017-08-29T02:05:54.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取整个页面数据"><a href="#获取整个页面数据" class="headerlink" title="获取整个页面数据"></a>获取整个页面数据</h2><p>先获取要下载图片的整个页面信息。<br>getjpg.py<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">import urllib</div><div class="line"></div><div class="line">def getHtml(url):</div><div class="line">    page = urllib.urlopen(url)</div><div class="line">    html = page.read()</div><div class="line">    <span class="built_in">return</span> html</div><div class="line"></div><div class="line">html = getHtml(<span class="string">"http://tieba.baidu.com/p/2738151262"</span>)</div><div class="line"></div><div class="line"><span class="built_in">print</span> html</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>Urllib模块提供了读取web页面数据的接口，可以像读取本地文件一样读取www和ftp上的数据。<br>首先，定义了一个getHtml()函数:<br>urllib.urlopen()方法用于打开一个URL地址。<br>read()方法用于读取URL上的数据，向getHtml()函数传递一个网址，并把整个页面下载下来。执行程序就会把整个网页打印输出。</p>
<h2 id="筛选页面中想要的数据"><a href="#筛选页面中想要的数据" class="headerlink" title="筛选页面中想要的数据"></a>筛选页面中想要的数据</h2><p>假如找到了几张漂亮的壁纸，通过到前端查看工具。找到了图片的地址，如：src=”<a href="http://desk.zol.com.cn/bizhi/7150_88511_2.html”" target="_blank" rel="external">http://desk.zol.com.cn/bizhi/7150_88511_2.html”</a><br><img src="/2017/08/29/python实现简单爬虫/1.png" alt=""><br>修改代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">import urllib</div><div class="line"></div><div class="line">def getHtml(url):</div><div class="line">    page = urllib.urlopen(url)</div><div class="line">    html = page.read()</div><div class="line">    <span class="built_in">return</span> html</div><div class="line"></div><div class="line">def getImg(html):</div><div class="line">    reg = r<span class="string">'src="(.+?\.jpg)" pic_ext'</span></div><div class="line">    imgre = re.compile(reg)</div><div class="line">    imglist = re.findall(imgre,html)</div><div class="line">    <span class="built_in">return</span> imglist      </div><div class="line">   </div><div class="line">html = getHtml(<span class="string">"http://tieba.baidu.com/p/2460150866"</span>)</div><div class="line"><span class="built_in">print</span> getImg(html)</div></pre></td></tr></table></figure></p>
<p>此时又创建了getImg()函数，用于在获取的整个页面中筛选需要的图片连接。re模块主要包含了正则表达式：<br>re.compile() 可以把正则表达式编译成一个正则表达式对象.<br>re.findall() 方法读取html 中包含 imgre（正则表达式）的数据。<br>运行脚本将得到整个页面中包含图片的URL地址。</p>
<h2 id="将页面筛选的数据保存到本地"><a href="#将页面筛选的数据保存到本地" class="headerlink" title="将页面筛选的数据保存到本地"></a>将页面筛选的数据保存到本地</h2><p>把筛选的图片地址通过for循环遍历并保存到本地，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">import urllib</div><div class="line">import re</div><div class="line"></div><div class="line">def getHtml(url):</div><div class="line">    page = urllib.urlopen(url)</div><div class="line">    html = page.read()</div><div class="line">    <span class="built_in">return</span> html</div><div class="line"></div><div class="line">def getImg(html):</div><div class="line">    reg = r<span class="string">'src="(.+?\.jpg)" pic_ext'</span></div><div class="line">    imgre = re.compile(reg)</div><div class="line">    imglist = re.findall(imgre,html)</div><div class="line">    x = 0</div><div class="line">    <span class="keyword">for</span> imgurl <span class="keyword">in</span> imglist:</div><div class="line">        urllib.urlretrieve(imgurl,<span class="string">'%s.jpg'</span> % x)</div><div class="line">        x+=1</div><div class="line"></div><div class="line">html = getHtml(<span class="string">"http://tieba.baidu.com/p/2460150866"</span>)</div><div class="line"></div><div class="line"><span class="built_in">print</span> getImg(html)</div></pre></td></tr></table></figure></p>
<p>这里的核心是用到了urllib.urlretrieve()方法，直接将远程数据下载到本地。<br>通过一个for循环对获取的图片连接进行遍历，为了使图片的文件名看上去更规范，对其进行重命名，命名规则通过x变量加1。保存的位置默认为程序的存放目录。<br>程序运行完成，将在目录下看到下载到本地的文件<br><img src="/2017/08/29/python实现简单爬虫/2.png" alt=""><br>注意：<br>运行上述代码可能会根据python版本的不同报错，我在爬虫的过程中就遇到了以下几个错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Missing parentheses <span class="keyword">in</span> call to <span class="string">'print'</span>——python语法错误</div></pre></td></tr></table></figure></p>
<p>这个消息的意思是你正在试图用python3.x来运行一个只用于python2.x版本的python脚本。<br>print”Hello world”<br>上面的语法在python3中是错误的。在python3中，你需要将helloworld加括号，正确的写法如下<br>print(“Hello world”)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">“AttributeError: <span class="string">'module'</span> object has no attribute <span class="string">'urlopen'</span>”</div></pre></td></tr></table></figure></p>
<p>原因是Python3里的urllib模块已经发生改变，此处的urllib都应该改成urllib.request。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TypeError: can<span class="string">'t use a string pattern on a bytes-like object</span></div></pre></td></tr></table></figure></p>
<p>原因为Python3 findall数据类型用bytes类型，因此在正则表达式前应添加html = html.decode(‘utf-8’)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;获取整个页面数据&quot;&gt;&lt;a href=&quot;#获取整个页面数据&quot; class=&quot;headerlink&quot; title=&quot;获取整个页面数据&quot;&gt;&lt;/a&gt;获取整个页面数据&lt;/h2&gt;&lt;p&gt;先获取要下载图片的整个页面信息。&lt;br&gt;getjpg.py&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#coding=utf-8&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import urllib&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;def getHtml(url):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    page = urllib.urlopen(url)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    html = page.read()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; html&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;html = getHtml(&lt;span class=&quot;string&quot;&gt;&quot;http://tieba.baidu.com/p/2738151262&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; html&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://weibo.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>python操作mysql数据库</title>
    <link href="http://weibo.com/2017/08/28/python%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://weibo.com/2017/08/28/python操作mysql数据库/</id>
    <published>2017-08-28T08:59:36.000Z</published>
    <updated>2017-08-29T01:30:05.408Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">import MySQLdb</div><div class="line"></div><div class="line">conn= MySQLdb.connect(</div><div class="line">        host=<span class="string">'localhost'</span>,</div><div class="line">        port = 3306,</div><div class="line">        user=<span class="string">'root'</span>,</div><div class="line">        passwd=<span class="string">'123456'</span>,</div><div class="line">        db =<span class="string">'test'</span>,</div><div class="line">        )</div><div class="line">cur = conn.cursor()</div><div class="line"></div><div class="line"><span class="comment">#创建数据表</span></div><div class="line"><span class="comment">#cur.execute("create table student(id int ,name varchar(20),class varchar(30),age varchar(10))")</span></div><div class="line"></div><div class="line"><span class="comment">#插入一条数据</span></div><div class="line"><span class="comment">#cur.execute("insert into student values('2','Tom','3 year 2 class','9')")</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改查询条件的数据</span></div><div class="line"><span class="comment">#cur.execute("update student set class='3 year 1 class' where name = 'Tom'")</span></div><div class="line"></div><div class="line"><span class="comment">#删除查询条件的数据</span></div><div class="line"><span class="comment">#cur.execute("delete from student where age='9'")</span></div><div class="line"></div><div class="line">cur.close()</div><div class="line">conn.commit()</div><div class="line">conn.close()</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>-&gt;&gt;&gt; conn = MySQLdb.connect(host=’localhost’,port = 3306,user=’root’, passwd=’123456’,db =’test’,)<br>Connect() 方法用于创建数据库的连接，里面可以指定参数：用户名，密码，主机等信息。<br>这只是连接到了数据库，要想操作数据库需要创建游标。<br>-&gt;&gt;&gt; cur = conn.cursor()<br>通过获取到的数据库连接conn下的cursor()方法来创建游标。<br>-&gt;&gt;&gt; cur.execute(“create table student(id int ,name varchar(20),class varchar(30),age varchar(10))”)<br>通过游标cur 操作execute()方法可以写入纯sql语句。通过execute()方法中写如sql语句来对数据进行操作。<br>-&gt;&gt;&gt;cur.close()<br>cur.close() 关闭游标<br>-&gt;&gt;&gt;conn.commit()<br>conn.commit()方法在提交事物，在向数据库插入一条数据时必须要有这个方法，否则数据不会被真正的插入。<br>-&gt;&gt;&gt;conn.close()<br>Conn.close()关闭数据库连接</p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>通过上面execute()方法中写入纯的sql语句来插入数据并不方便。如：<br>-&gt;&gt;&gt;cur.execute(“insert into student values(‘2’,’Tom’,’3 year 2 class’,’9’)”)<br>我要想插入新的数据，必须要对这条语句中的值做修改。我们可以做如下修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">import MySQLdb</div><div class="line"></div><div class="line">conn= MySQLdb.connect(</div><div class="line">        host=<span class="string">'localhost'</span>,</div><div class="line">        port = 3306,</div><div class="line">        user=<span class="string">'root'</span>,</div><div class="line">        passwd=<span class="string">'123456'</span>,</div><div class="line">        db =<span class="string">'test'</span>,</div><div class="line">        )</div><div class="line">cur = conn.cursor()</div><div class="line"></div><div class="line"><span class="comment">#插入一条数据</span></div><div class="line">sqli=<span class="string">"insert into student values(%s,%s,%s,%s)"</span></div><div class="line">cur.execute(sqli,(<span class="string">'3'</span>,<span class="string">'Huhu'</span>,<span class="string">'2 year 1 class'</span>,<span class="string">'7'</span>))</div><div class="line"></div><div class="line">cur.close()</div><div class="line">conn.commit()</div><div class="line">conn.close()</div></pre></td></tr></table></figure>
<p>一次向数据表中插入多条值:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">import MySQLdb</div><div class="line"></div><div class="line">conn= MySQLdb.connect(</div><div class="line">        host=<span class="string">'localhost'</span>,</div><div class="line">        port = 3306,</div><div class="line">        user=<span class="string">'root'</span>,</div><div class="line">        passwd=<span class="string">'123456'</span>,</div><div class="line">        db =<span class="string">'test'</span>,</div><div class="line">        )</div><div class="line">cur = conn.cursor()</div><div class="line"></div><div class="line"><span class="comment">#一次插入多条记录</span></div><div class="line">sqli=<span class="string">"insert into student values(%s,%s,%s,%s)"</span></div><div class="line">cur.executemany(sqli,[</div><div class="line">    (<span class="string">'3'</span>,<span class="string">'Tom'</span>,<span class="string">'1 year 1 class'</span>,<span class="string">'6'</span>),</div><div class="line">    (<span class="string">'3'</span>,<span class="string">'Jack'</span>,<span class="string">'2 year 1 class'</span>,<span class="string">'7'</span>),</div><div class="line">    (<span class="string">'3'</span>,<span class="string">'Yaheng'</span>,<span class="string">'2 year 2 class'</span>,<span class="string">'7'</span>),</div><div class="line">    ])</div><div class="line"></div><div class="line">cur.close()</div><div class="line">conn.commit()</div><div class="line">conn.close()</div></pre></td></tr></table></figure></p>
<p>executemany()方法可以一次插入多条值，执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数。</p>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>也许你已经尝试了在python中通过<br>-&gt;&gt;&gt;cur.execute(“select <em> from student”)<br>来查询数据表中的数据，但它并没有把表中的数据打印出来，有些失望。<br>来看看这条语句获得的是什么<br>-&gt;&gt;&gt;aa=cur.execute(“select </em> from student”)<br>-&gt;&gt;&gt;print aa<br>-5<br>它获得的只是我们的表中有多少条数据。那怎样才能获得表中的数据呢？进入python shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import MySQLdb</div><div class="line">&gt;&gt;&gt; conn = MySQLdb.connect(host=<span class="string">'localhost'</span>,port = 3306,user=<span class="string">'root'</span>,    passwd=<span class="string">'123456'</span>,db =<span class="string">'test'</span>,)</div><div class="line">&gt;&gt;&gt; cur = conn.cursor()</div><div class="line">&gt;&gt;&gt; cur.execute(<span class="string">"select * from student"</span>)</div><div class="line">5L</div><div class="line">&gt;&gt;&gt; cur.fetchone()</div><div class="line">(1L, <span class="string">'Alen'</span>, <span class="string">'1 year 2 class'</span>, <span class="string">'6'</span>)</div><div class="line">&gt;&gt;&gt; cur.fetchone()</div><div class="line">(3L, <span class="string">'Huhu'</span>, <span class="string">'2 year 1 class'</span>, <span class="string">'7'</span>)</div><div class="line">&gt;&gt;&gt; cur.fetchone()</div><div class="line">(3L, <span class="string">'Tom'</span>, <span class="string">'1 year 1 class'</span>, <span class="string">'6'</span>)</div><div class="line">...</div><div class="line">&gt;&gt;&gt;cur.scroll(0,<span class="string">'absolute'</span>)</div></pre></td></tr></table></figure>
<p>fetchone()方法可以帮助我们获得表中的数据，可是每次执行cur.fetchone() 获得的数据都不一样，换句话说我没执行一次，游标会从表中的第一条数据移动到下一条数据的位置，所以，我再次执行的时候得到的是第二条数据。<br>scroll(0,’absolute’) 方法可以将游标定位到表中的第一条数据。<br>还是没解决我们想要的结果，如何获得表中的多条数据并打印出来呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">import MySQLdb</div><div class="line"></div><div class="line">conn= MySQLdb.connect(</div><div class="line">        host=<span class="string">'localhost'</span>,</div><div class="line">        port = 3306,</div><div class="line">        user=<span class="string">'root'</span>,</div><div class="line">        passwd=<span class="string">'123456'</span>,</div><div class="line">        db =<span class="string">'test'</span>,</div><div class="line">        )</div><div class="line">cur = conn.cursor()</div><div class="line"></div><div class="line"><span class="comment">#获得表中有多少条数据</span></div><div class="line">aa=cur.execute(<span class="string">"select * from student"</span>)</div><div class="line"><span class="built_in">print</span> aa</div><div class="line"></div><div class="line"><span class="comment">#打印表中的多少数据</span></div><div class="line">info = cur.fetchmany(aa)</div><div class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> info:</div><div class="line">    <span class="built_in">print</span> ii</div><div class="line">cur.close()</div><div class="line">conn.commit()</div><div class="line">conn.close()</div></pre></td></tr></table></figure></p>
<p>通过之前的print aa 我们知道当前的表中有5条数据，fetchmany()方法可以获得多条数据，但需要指定数据的条数，通过一个for循环就可以把多条数据打印出啦！执行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(1L, <span class="string">'Alen'</span>, <span class="string">'1 year 2 class'</span>, <span class="string">'6'</span>)</div><div class="line">(3L, <span class="string">'Huhu'</span>, <span class="string">'2 year 1 class'</span>, <span class="string">'7'</span>)</div><div class="line">(3L, <span class="string">'Tom'</span>, <span class="string">'1 year 1 class'</span>, <span class="string">'6'</span>)</div><div class="line">(3L, <span class="string">'Jack'</span>, <span class="string">'2 year 1 class'</span>, <span class="string">'7'</span>)</div><div class="line">(3L, <span class="string">'Yaheng'</span>, <span class="string">'2 year 2 class'</span>, <span class="string">'7'</span>)</div><div class="line">[Finished <span class="keyword">in</span> 0.1s]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#coding=utf-8&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import MySQLdb&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;conn= MySQLdb.connect(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        host=&lt;span class=&quot;string&quot;&gt;&#39;localhost&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        port = 3306,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        user=&lt;span class=&quot;string&quot;&gt;&#39;root&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        passwd=&lt;span class=&quot;string&quot;&gt;&#39;123456&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        db =&lt;span class=&quot;string&quot;&gt;&#39;test&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cur = conn.cursor()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#创建数据表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#cur.execute(&quot;create table student(id int ,name varchar(20),class varchar(30),age varchar(10))&quot;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#插入一条数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#cur.execute(&quot;insert into student values(&#39;2&#39;,&#39;Tom&#39;,&#39;3 year 2 class&#39;,&#39;9&#39;)&quot;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#修改查询条件的数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#cur.execute(&quot;update student set class=&#39;3 year 1 class&#39; where name = &#39;Tom&#39;&quot;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#删除查询条件的数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#cur.execute(&quot;delete from student where age=&#39;9&#39;&quot;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cur.close()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;conn.commit()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;conn.close()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python,mySQL" scheme="http://weibo.com/categories/python-mySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>SQLite了解数据库操作</title>
    <link href="http://weibo.com/2017/08/28/SQLite%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>http://weibo.com/2017/08/28/SQLite了解数据库操作/</id>
    <published>2017-08-28T08:08:18.000Z</published>
    <updated>2017-08-28T08:35:01.613Z</updated>
    
    <content type="html"><![CDATA[<p>sqlite是非常著名的开源嵌入式数据库软件，它可以嵌入到其他程序中使用，并且提供SQL接口用来查询，非常方便。它的官方站点为<a href="http://www.sqlite.org" target="_blank" rel="external">http://www.sqlite.org</a>。<br>而pysqlite 则是一个 sqlite 为 python 提供的 api 接口，它让一切对于 sqlite 的操作都变得异常简单<br>在python2.5版本这后，SQLite的优势在于它的一个包装（PySQLite）已经被包括在标准库内，所以我们可以直接使用。<br><a id="more"></a><br>可以将SQLite作为名为sqlite3的模块导入。之后就可以创建一个到数据库文件的连接—-如果文件不存在就会被创建—-通过提供一个文件名：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import sqlite3</div><div class="line">&gt;&gt;&gt; conn = sqlite3.connect(<span class="string">'somedatabase.db'</span>) <span class="comment"># 创建数据库</span></div><div class="line">&gt;&gt;&gt; cu = conn.cursor()   <span class="comment">#能获得连接的游标</span></div><div class="line"></div><div class="line"><span class="comment">#创建数据表</span></div><div class="line">&gt;&gt;&gt; cu.execute(<span class="string">""</span><span class="string">"create table catalog (</span></div><div class="line"><span class="string">    id integer primary key,</span></div><div class="line"><span class="string">    pid integer,</span></div><div class="line"><span class="string">    name varchar(10) UNIQUE</span></div><div class="line"><span class="string">   )"</span><span class="string">""</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#插入两条数据</span></div><div class="line">&gt;&gt;&gt; cu.execute(<span class="string">"insert into catalog values(0,0,'name1')"</span>)</div><div class="line">&gt;&gt;&gt; cu.execute(<span class="string">"insert into catalog values(1,0,'name2')"</span>)</div><div class="line">&gt;&gt;&gt; conn.commit()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#选择（select）</span></div><div class="line">&gt;&gt;&gt; cu.execute(<span class="string">"select * from catalog"</span>)</div><div class="line">&gt;&gt;&gt; cu.fetchall()  </div><div class="line">[(0, 0, <span class="string">'name1'</span>), (1, 0, <span class="string">'name2'</span>)]</div><div class="line">&gt;&gt;&gt; cu.execute(<span class="string">"select * from catalog where id = 1"</span>)</div><div class="line">&gt;&gt;&gt; cu.fetchall()</div><div class="line">[(1, 0, <span class="string">'name2'</span>)]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改（update）</span></div><div class="line">&gt;&gt;&gt; cu.execute(“update catalog <span class="built_in">set</span> name=’name2′ <span class="built_in">where</span> id = 0″)</div><div class="line">&gt;&gt;&gt; cx.commit()</div><div class="line">&gt;&gt;&gt; cu.execute(“select * from catalog”)</div><div class="line">&gt;&gt;&gt; cu.fetchone()</div><div class="line">(0, 0, ‘name2′)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#删除（delete）</span></div><div class="line">&gt;&gt;&gt; cu.execute(“delete from catalog <span class="built_in">where</span> id = 1″)</div><div class="line">&gt;&gt;&gt; cx.commit()</div><div class="line">&gt;&gt;&gt; cu.execute(“select * from catalog”)</div><div class="line">&gt;&gt;&gt; cu.fetchall()</div><div class="line">[(0, 0, <span class="string">'name2'</span>)]</div></pre></td></tr></table></figure></p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>为了使用基础数据库系统，首先必须连接到它，这个时候需要使用具有名称的connect函数，该函数有多个参数，而具体用哪个参数取决于数据库。</p>
<h3 id="connect函数的常用参数："><a href="#connect函数的常用参数：" class="headerlink" title="connect函数的常用参数："></a>connect函数的常用参数：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dsn             数据源名称，给出该参数表示数据依赖               不可选</div><div class="line">user            用户名                                           可选</div><div class="line">password        用户密码                                         可选</div><div class="line">host            主机名                                           可选</div><div class="line">database        数据库                                           可选</div></pre></td></tr></table></figure>
<p>connect函数返回连接对象。这个对象表示目前和数据库的会话。</p>
<h3 id="连接对象方法："><a href="#连接对象方法：" class="headerlink" title="连接对象方法："></a>连接对象方法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">clos（）                 关闭连接之后，连接对象和它的游标均不可用</div><div class="line">commit（）               如果支持的话就提交挂起的事务，否则不做任何事</div><div class="line">rollback（）             回滚挂起的事务</div><div class="line">cursor（）               返回连接的游标对象</div></pre></td></tr></table></figure>
<p>commit 方法总是可用的，但如果数据库不支持事务，它就没有任何作用。如果关闭了连接但还有未提交的事务，它们会隐式地回滚—但是只有在数据库支持持回滚的时候才可以。<br>rollback 方法可能不可用，因为不是所有的数据库都支持事务（事务是一系列动作）。如果可用，那么就可以“撤销”所有未提交的事务。<br>cursor 方法将我们引入另外一个主题：游标对象。通过游标扫行SQL 查询并检查结果。游标连接支持更多的方法，而且可能在程序中更好用。</p>
<h2 id="游标："><a href="#游标：" class="headerlink" title="游标："></a>游标：</h2><p>cu = conn.cursor()<br>能获得连接的游标，这个游标可以用来执行SQL查询。<br>conn.commit()<br>完成插入并且做出某些更改后确保已经进行了提交，这样才可以将这些修改真正地保存到文件中。</p>
<h3 id="游标对象方法："><a href="#游标对象方法：" class="headerlink" title="游标对象方法："></a>游标对象方法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">callproc（name[,params]）       使用给定的名称和参数调用已命名的数据库程序</div><div class="line">close（）                       关闭游标之后，游标不可用</div><div class="line">execute（oper[,params]）        执行SQL操作，可能使用参数</div><div class="line">executemany（oper,pseq）        对序列中的每个参数执行SQL操作</div><div class="line">fetchone（）                    把查询的结果集中的下一行保存为序列，或者None</div><div class="line">fetchmany（[size]）             获取查询结果集中的多行，默认尺寸为arraysize</div><div class="line">fetchall（）                    将所有（剩余）的行作为序列的序列</div><div class="line">nextset（）                     跳至下一个可用的结果集（可选）</div><div class="line">setinputsizes（sizes）          为参数预先定义内存区域</div><div class="line">setoutputsize（size[,col]）     为获取的大数据值设定缓冲区尺寸</div></pre></td></tr></table></figure>
<h3 id="游标对象特性："><a href="#游标对象特性：" class="headerlink" title="游标对象特性："></a>游标对象特性：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">description                     结果列描述的序列，只读</div><div class="line">rowcount                        结果中的行数，保读</div><div class="line">arraysize                       fetchmany中返回的行数，默认为1</div></pre></td></tr></table></figure>
<p>cu.fetchone()<br>fetchall()返回结果集中的全部数据，结果为一个tuple的列表。每个tuple元素是按建表的字段顺序排列。注意，游标是有状态的，它可以记录当前已经取到结果的第几个记录了，因此，一般你只可以遍历结果集一次。在上面的情况下，如果执行fetchone()会返回为空。这一点在测试时需要注意。<br>conn.close()<br>可以在每次修改数据库后都进行提交，而不是仅仅在准备关闭才提交，准备关闭数据时，使用close 方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sqlite是非常著名的开源嵌入式数据库软件，它可以嵌入到其他程序中使用，并且提供SQL接口用来查询，非常方便。它的官方站点为&lt;a href=&quot;http://www.sqlite.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.sqlite.org&lt;/a&gt;。&lt;br&gt;而pysqlite 则是一个 sqlite 为 python 提供的 api 接口，它让一切对于 sqlite 的操作都变得异常简单&lt;br&gt;在python2.5版本这后，SQLite的优势在于它的一个包装（PySQLite）已经被包括在标准库内，所以我们可以直接使用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python,SQLite，PySQLite" scheme="http://weibo.com/categories/python-SQLite%EF%BC%8CPySQLite/"/>
    
    
  </entry>
  
  <entry>
    <title>WebSocket与消息推送</title>
    <link href="http://weibo.com/2017/08/22/WebSocket%E4%B8%8E%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    <id>http://weibo.com/2017/08/22/WebSocket与消息推送/</id>
    <published>2017-08-22T06:07:08.000Z</published>
    <updated>2017-08-22T06:47:31.527Z</updated>
    
    <content type="html"><![CDATA[<p>写完上篇文章猛然发现，怎么不懂的还是那么多，真是一个技术能关联的技术真是太多了，没有足够的功夫和时间真的很难以掌握呢！比如TCP/IP的三次握手，四次握手，这个下一篇文章细讲，现在想讲的是一种新的通信协议WebSocket。<br>首先还是回顾一下Socket，来看一下Socket的通信模型：<br><img src="/2017/08/22/WebSocket与消息推送/socket.png" alt=""><br>Socket可以使用TCP/IP协议或者UDP协议。<br><a id="more"></a></p>
<h2 id="socket通信流程"><a href="#socket通信流程" class="headerlink" title="socket通信流程"></a>socket通信流程</h2><p>socket是”打开—读/写—关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的<br><img src="/2017/08/22/WebSocket与消息推送/socket_1.png" alt=""><br>服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket<br>服务器为socket绑定ip地址和端口号<br>服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开<br>客户端创建socket<br>客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket<br>服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求<br>客户端连接成功，向服务器发送连接状态信息<br>服务器accept方法返回，连接成功<br>客户端向socket写入信息<br>服务器读取信息<br>客户端关闭<br>服务器端关闭</p>
<h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>TCP协议:<br>面向连接的、可靠的、基于字节流的传输层通信协议，负责数据的可靠性传输的问题。<br>IP协议:<br>用于报文交换网络的一种面向数据的协议，主要负责给每台网络设备一个网络地址，保证数据传输到正确的目的地。</p>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>UDP特点：<br>无连接、不可靠、基于报文的传输层协议，优点是发送后不用管，速度比TCP快。</p>
<h2 id="WebSocket简介与消息推送"><a href="#WebSocket简介与消息推送" class="headerlink" title="WebSocket简介与消息推送"></a>WebSocket简介与消息推送</h2><p>B/S架构的系统多使用HTTP协议，HTTP协议的特点：<br>1 无状态协议<br>2 用于通过 Internet 发送请求消息和响应消息<br>3 使用端口接收和发送消息，默认为80端口<br>底层通信还是使用Socket完成。<br><img src="/2017/08/22/WebSocket与消息推送/websocket.png" alt=""><br>HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送（F5已坏）,一些变相的解决办法：<br>双向通信与消息推送</p>
<h3 id="轮询："><a href="#轮询：" class="headerlink" title="轮询："></a>轮询：</h3><p>客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 优点：后端程序编写比较容易。<br>缺点：请求中有大半是无用，浪费带宽和服务器资源。<br>实例：适于小型应用。</p>
<h3 id="长轮询："><a href="#长轮询：" class="headerlink" title="长轮询："></a>长轮询：</h3><p>客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 优点：在无消息的情况下不会频繁的请求，耗费资小。 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet异步的ashx，<br>实例：WebQQ、Hi网页版、Facebook IM。</p>
<h3 id="长连接："><a href="#长连接：" class="headerlink" title="长连接："></a>长连接：</h3><p>在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。 优点：消息即时到达，不发无用请求；管理起来也相对便。 缺点：服务器维护一个长连接会增加开销。<br>实例：Gmail聊天</p>
<h3 id="Flash-Socket："><a href="#Flash-Socket：" class="headerlink" title="Flash Socket："></a>Flash Socket：</h3><p>在页面中内嵌入一个使用了Socket类的 Flash 程序JavaScript通过调用此Flash程序提供的Socket接口与服务器端的Socket接口进行通信，JavaScript在收到服务器端传送的信息后控制页面的显示。<br>优点：实现真正的即时通信，而不是伪即时。 缺点：客户端必须安装Flash插件；非HTTP协议，无法自动穿越防火墙。 实例：网络互动游戏。</p>
<h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket:"></a>Websocket:</h3><p>WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。<br>特点:<br>事件驱动<br>异步<br>使用ws或者wss协议的客户端socket<br>能够实现真正意义上的推送功能<br>缺点：<br>少部分浏览器不支持，浏览器支持的程度与方式有区别。<br><img src="/2017/08/22/WebSocket与消息推送/websocket_1.png" alt=""></p>
<h2 id="WebSocket客户端"><a href="#WebSocket客户端" class="headerlink" title="WebSocket客户端"></a>WebSocket客户端</h2><p>websocket允许通过JavaScript建立与远程服务器的连接，从而实现客户端与服务器间双向的通信。<br>在websocket中有两个方法：　　<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1、send() 向远程服务器发送数据</div><div class="line">2、close() 关闭该websocket链接</div></pre></td></tr></table></figure></p>
<p>websocket同时还定义了几个监听函数　　　　<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1、onopen 当网络连接建立时触发该事件</div><div class="line">2、onerror 当网络发生错误时触发该事件</div><div class="line">3、onclose 当websocket被关闭时触发该事件</div><div class="line">4、onmessage 当websocket接收到服务器发来的消息的时触发的事件，也是通信中最重要的一个监听事件。msg.data</div></pre></td></tr></table></figure></p>
<p>websocket还定义了一个readyState属性，这个属性可以返回websocket所处的状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1、CONNECTING(0) websocket正尝试与服务器建立连接</div><div class="line">2、OPEN(1) websocket与服务器已经建立连接</div><div class="line">3、CLOSING(2) websocket正在关闭与服务器的连接</div><div class="line">4、CLOSED(3) websocket已经关闭了与服务器的连接</div></pre></td></tr></table></figure></p>
<p>websocket的url开头是ws，如果需要ssl(Secure Sockets Layer 安全套接层)加密可以使用wss，当我们调用websocket的构造方法构建一个websocket对象（new WebSocket(url)）的之后，就可以进行即时通信了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width"</span> /&gt;</div><div class="line">        &lt;title&gt;WebSocket 客户端&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"btnConnection"</span> value=<span class="string">"连接"</span> /&gt;</div><div class="line">            &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"btnClose"</span> value=<span class="string">"关闭"</span> /&gt;</div><div class="line">            &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"btnSend"</span> value=<span class="string">"发送"</span> /&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;script src=<span class="string">"js/jquery-1.11.1.min.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</div><div class="line">        &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</div><div class="line">            var socket;</div><div class="line">            <span class="keyword">if</span>(typeof(WebSocket) == <span class="string">"undefined"</span>) &#123;</div><div class="line">                alert(<span class="string">"您的浏览器不支持WebSocket"</span>);</div><div class="line">                <span class="built_in">return</span>;</div><div class="line">            &#125;</div><div class="line">            $(<span class="string">"#btnConnection"</span>).click(<span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">                //实现化WebSocket对象，指定要连接的服务器地址与端口</div><div class="line">                socket = new WebSocket(<span class="string">"ws://192.168.1.2:8888"</span>);</div><div class="line">                //打开事件</div><div class="line">                socket.onopen = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">                    alert(<span class="string">"Socket 已打开"</span>);</div><div class="line">                    //socket.send(<span class="string">"这是来自客户端的消息"</span> + location.href + new Date());</div><div class="line">                &#125;;</div><div class="line">                //获得消息事件</div><div class="line">                socket.onmessage = <span class="keyword">function</span>(msg) &#123;</div><div class="line">                    alert(msg.data);</div><div class="line">                &#125;;</div><div class="line">                //关闭事件</div><div class="line">                socket.onclose = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">                    alert(<span class="string">"Socket已关闭"</span>);</div><div class="line">                &#125;;</div><div class="line">                //发生了错误事件</div><div class="line">                socket.onerror = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">                    alert(<span class="string">"发生了错误"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            //发送消息</div><div class="line">            $(<span class="string">"#btnSend"</span>).click(<span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">                socket.send(<span class="string">"这是来自客户端的消息"</span> + location.href + new Date());</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">            //关闭</div><div class="line">            $(<span class="string">"#btnClose"</span>).click(<span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">                socket.close();</div><div class="line">            &#125;);</div><div class="line">        &lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h2 id="带Socket-IO的WebSocket"><a href="#带Socket-IO的WebSocket" class="headerlink" title="带Socket.IO的WebSocket"></a>带Socket.IO的WebSocket</h2><p>Socket.IO是WebSocket API<br>建立客户端Socket.IO<br>Socket.IO可以从GitHub下载，可以把socket.io.js文件包含到页面中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"http://cdn.socket.io/stable/socket.io.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>此时，Socket.IO在此页面上是有效的，是时候创建Socket了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 创建Socket.IO实例，建立连接</div><div class="line">var socket= new io.Socket(<span class="string">'localhost'</span>,&#123; </div><div class="line">  port: 8080 </div><div class="line">&#125;); </div><div class="line">socket.connect(); </div><div class="line"></div><div class="line">// 添加一个连接监听器</div><div class="line">socket.on(<span class="string">'connect'</span>,<span class="function"><span class="title">function</span></span>() &#123; </div><div class="line">  console.log(<span class="string">'Client has connected to the server!'</span>); </div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 添加一个连接监听器</div><div class="line">socket.on(<span class="string">'message'</span>,<span class="keyword">function</span>(data) &#123; </div><div class="line">  console.log(<span class="string">'Received a message from the server!'</span>,data); </div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 添加一个关闭连接的监听器</div><div class="line">socket.on(<span class="string">'disconnect'</span>,<span class="function"><span class="title">function</span></span>() &#123; </div><div class="line">  console.log(<span class="string">'The client has disconnected!'</span>); </div><div class="line">&#125;); </div><div class="line"></div><div class="line">// 通过Socket发送一条消息到服务器</div><div class="line"><span class="keyword">function</span> sendMessageToServer(message) &#123; </div><div class="line">  socket.send(message); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Socket.IO简化了WebSocket API，统一了返回运输的API。传输包括：<br>WebSocket<br>Flash Socket<br>AJAX long-polling<br>AJAX multipart streaming<br>IFrame<br>JSONP polling<br>你还可以设置任意的Socket.IO构造器的第二个选项，选项包括：<br>port - 待连接的端口<br>transports - 一个数组，包含不同的传输类型<br>transportOptions - 传输的参数使用的对象，带附加属性<br>Socket.IO还提供了由本地WebSocket API提供的普通连接、断开连接、消息事件。Socket还提供了封装每个事件类型的方法。</p>
<h2 id="NodeJS和Socket-IO联合开发"><a href="#NodeJS和Socket-IO联合开发" class="headerlink" title="NodeJS和Socket.IO联合开发"></a>NodeJS和Socket.IO联合开发</h2><p>Socket.IO提供的服务器端解决方案，允许统一的客户端和服务器端的API。使用Node，你可以创建一个典型的HTTP服务器，然后把服务器的实例传递到Socket.IO。从这里，你创建连接、断开连接、建立消息监听器，跟在客户端一样。<br>一个简单的服务器端脚本看起来如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 需要HTTP 模块来启动服务器和Socket.IO</div><div class="line">var http= require(<span class="string">'http'</span>), io= require(<span class="string">'socket.io'</span>); </div><div class="line"></div><div class="line">// 在8080端口启动服务器</div><div class="line">var server= http.createServer(<span class="keyword">function</span>(req, res)&#123; </div><div class="line">  // 发送HTML的headers和message</div><div class="line">  res.writeHead(200,&#123; <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span> &#125;); </div><div class="line">  res.end(<span class="string">'&lt;h1&gt;Hello Socket Lover!&lt;/h1&gt;'</span>); </div><div class="line">&#125;); </div><div class="line">server.listen(8080); </div><div class="line"></div><div class="line">// 创建一个Socket.IO实例，把它传递给服务器</div><div class="line">var socket= io.listen(server); </div><div class="line"></div><div class="line">// 添加一个连接监听器</div><div class="line">socket.on(<span class="string">'connection'</span>, <span class="keyword">function</span>(client)&#123; </div><div class="line"></div><div class="line">  // 成功！现在开始监听接收到的消息</div><div class="line">  client.on(<span class="string">'message'</span>,<span class="keyword">function</span>(event)&#123; </div><div class="line">    console.log(<span class="string">'Received message from client!'</span>,event); </div><div class="line">  &#125;); </div><div class="line">  client.on(<span class="string">'disconnect'</span>,<span class="function"><span class="title">function</span></span>()&#123; </div><div class="line">    clearInterval(interval); </div><div class="line">    console.log(<span class="string">'Server has disconnected'</span>); </div><div class="line">  &#125;); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>你可以运行服务器部分，假定已安装了NodeJS，从命令行执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node socket-server.js</div></pre></td></tr></table></figure></p>
<p>现在客户端和服务器都能来回推送消息了！在NodeJS脚本内，可以使用简单的JavaScript创建一个定期消息发送器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 创建一个定期（每5秒）发送消息到客户端的发送器</div><div class="line">var interval= setInterval(<span class="function"><span class="title">function</span></span>() &#123; </div><div class="line">  client.send(<span class="string">'This is a message from the server! '</span> + new Date().getTime()); </div><div class="line">&#125;,5000);</div></pre></td></tr></table></figure></p>
<p>服务器端将会每5秒推送消息到客户端！</p>
<h2 id="dojox-Socket和Socket-IO"><a href="#dojox-Socket和Socket-IO" class="headerlink" title="dojox.Socket和Socket.IO"></a>dojox.Socket和Socket.IO</h2><p>dojox.Socket以Dojo库一致的方式封装了WebSocket API，用于在客户端不支持WebSocket时，使用long-polling替代。<br>下面是怎样在客户端使用dojox.Socket和在服务器端使用Socket.IO的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var args, ws= typeof WebSocket!= <span class="string">'undefined'</span>; </div><div class="line">var socket= dojox.socket(args= &#123; </div><div class="line">  url: ws? <span class="string">'/socket.io/websocket'</span> : <span class="string">'/socket.io/xhr-polling'</span>, </div><div class="line">  headers:&#123; </div><div class="line">    <span class="string">'Content-Type'</span>:<span class="string">'application/x-www-urlencoded'</span> </div><div class="line">  &#125;, </div><div class="line">  transport: <span class="keyword">function</span>(args, message)&#123; </div><div class="line">    args.content = message; // use URL-encoding to send the message instead of a raw body </div><div class="line">    dojo.xhrPost(args); </div><div class="line">  &#125;; </div><div class="line">&#125;); </div><div class="line">var sessionId; </div><div class="line">socket.on(<span class="string">'message'</span>, <span class="function"><span class="title">function</span></span>()&#123; </div><div class="line">  <span class="keyword">if</span> (!sessionId)&#123; </div><div class="line">    sessionId= message; </div><div class="line">    args.url += <span class="string">'/'</span> + sessionId; </div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(message.substr(0, 3) == <span class="string">'~h~'</span>)&#123; </div><div class="line">   // a heartbeat </div><div class="line">  &#125; </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="WebSocket资源"><a href="#WebSocket资源" class="headerlink" title="WebSocket资源"></a>WebSocket资源</h2><p>Socket.IO站点：<a href="http://socket.io/" target="_blank" rel="external">http://socket.io/</a><br>WebSocket的Wikipedia：<a href="http://en.wikipedia.org/wiki/WebSockets" target="_blank" rel="external">http://en.wikipedia.org/wiki/WebSockets</a><br>WebSockets.org站点：<a href="http://www.websockets.org/" target="_blank" rel="external">http://www.websockets.org/</a><br>Dojo WebSocket站点：<a href="http://www.sitepen.com/blog/2010/10/31/dojo-websocket/" target="_blank" rel="external">http://www.sitepen.com/blog/2010/10/31/dojo-websocket/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写完上篇文章猛然发现，怎么不懂的还是那么多，真是一个技术能关联的技术真是太多了，没有足够的功夫和时间真的很难以掌握呢！比如TCP/IP的三次握手，四次握手，这个下一篇文章细讲，现在想讲的是一种新的通信协议WebSocket。&lt;br&gt;首先还是回顾一下Socket，来看一下Socket的通信模型：&lt;br&gt;&lt;img src=&quot;/2017/08/22/WebSocket与消息推送/socket.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Socket可以使用TCP/IP协议或者UDP协议。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="socket,websocket" scheme="http://weibo.com/categories/socket-websocket/"/>
    
    
  </entry>
  
  <entry>
    <title>Socket通信原理</title>
    <link href="http://weibo.com/2017/08/22/Socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"/>
    <id>http://weibo.com/2017/08/22/Socket通信原理/</id>
    <published>2017-08-22T01:42:58.000Z</published>
    <updated>2017-08-22T03:17:38.701Z</updated>
    
    <content type="html"><![CDATA[<p>socket，什么是socket，我也不知道，之前有听过这个名词，但是没有去研究它。直到昨天一个同事问我，我们前台通过PHP将数据传给后台，是通过什么机制传数据的，前后台怎么进行通信的，后台又是怎么进行处理的，问的我真是一脸懵。于是在网上找了几篇觉得写得比较好的博客看了看，算是明白了一点。<br>我们先来看看socket的名词解释：<br>Socket的英文原义是“孔”或“插座”。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。<br>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。<br>建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；<br>HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。<br><a id="more"></a></p>
<h2 id="网络中进程之间如何通信？"><a href="#网络中进程之间如何通信？" class="headerlink" title="网络中进程之间如何通信？"></a>网络中进程之间如何通信？</h2><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：<br>消息传递（管道、FIFO、消息队列）<br>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）<br>共享内存（匿名的和具名的）<br>远程过程调用（Solaris门和Sun RPC）<br>如何唯一标识一个进程：<br>在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。<br>使用TCP/IP协议的应用程序通常采用应用编程接口：<br>UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是为什么说“一切皆socket”。</p>
<h2 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h2><p>上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。</p>
<h2 id="socket的基本操作"><a href="#socket的基本操作" class="headerlink" title="socket的基本操作"></a>socket的基本操作</h2><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p>
<h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int socket(int domain, int <span class="built_in">type</span>, int protocol);</div></pre></td></tr></table></figure>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。<br>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：<br>domain：<br>即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。<br>type：<br>指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。<br>protocol：<br>就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。<br>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。<br>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h3><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int <span class="built_in">bind</span>(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure></p>
<p>函数的三个参数分别为：<br>sockfd：<br>即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。<br>addr：<br>一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，<br>ipv4对应的是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct sockaddr_in &#123;</div><div class="line">    sa_family_t    sin_family; /* address family: AF_INET */</div><div class="line">    in_port_t      sin_port;   /* port <span class="keyword">in</span> network byte order */</div><div class="line">    struct in_addr sin_addr;   /* internet address */</div><div class="line">&#125;;</div><div class="line">/* Internet address. */</div><div class="line">struct in_addr &#123;</div><div class="line">    uint32_t       s_addr;     /* address <span class="keyword">in</span> network byte order */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>ipv6对应的是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct sockaddr_in6 &#123; </div><div class="line">    sa_family_t     sin6_family;   /* AF_INET6 */ </div><div class="line">    in_port_t       sin6_port;     /* port number */ </div><div class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </div><div class="line">    struct in6_addr sin6_addr;     /* IPv6 address */ </div><div class="line">    uint32_t        sin6_scope_id; /* Scope ID (new <span class="keyword">in</span> 2.4) */ </div><div class="line">&#125;;</div><div class="line">struct in6_addr &#123; </div><div class="line">    unsigned char   s6_addr[16];   /* IPv6 address */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Unix域对应的是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define UNIX_PATH_MAX    108</span></div><div class="line">struct sockaddr_un &#123; </div><div class="line">    sa_family_t sun_family;               /* AF_UNIX */ </div><div class="line">    char        sun_path[UNIX_PATH_MAX];  /* pathname */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>addrlen：<br>对应的是地址的长度。<br>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。<br>网络字节序与主机字节序<br>主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：<br>a)Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>b)Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。<br>所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</p>
<h2 id="listen-、connect-函数"><a href="#listen-、connect-函数" class="headerlink" title="listen()、connect()函数"></a>listen()、connect()函数</h2><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int listen(int sockfd, int backlog);</div><div class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure></p>
<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。<br>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h2 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h2><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</div></pre></td></tr></table></figure></p>
<p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。<br>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<h2 id="read-、write-等函数"><a href="#read-、write-等函数" class="headerlink" title="read()、write()等函数"></a>read()、write()等函数</h2><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<p>read()/write()<br>recv()/send()<br>readv()/writev()<br>recvmsg()/sendmsg()<br>recvfrom()/sendto()<br>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;unistd.h&gt;</span></div><div class="line">       ssize_t <span class="built_in">read</span>(int fd, void *buf, size_t count);</div><div class="line">       ssize_t write(int fd, const void *buf, size_t count);</div><div class="line">       <span class="comment">#include &lt;sys/types.h&gt;</span></div><div class="line">       <span class="comment">#include &lt;sys/socket.h&gt;</span></div><div class="line">       ssize_t send(int sockfd, const void *buf, size_t len, int flags);</div><div class="line">       ssize_t recv(int sockfd, void *buf, size_t len, int flags);</div><div class="line">       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</div><div class="line">                     const struct sockaddr *dest_addr, socklen_t addrlen);</div><div class="line">       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</div><div class="line">                        struct sockaddr *src_addr, socklen_t *addrlen);</div><div class="line">       ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</div><div class="line">       ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</div></pre></td></tr></table></figure></p>
<p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。<br>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p>
<h2 id="close-函数"><a href="#close-函数" class="headerlink" title="close()函数"></a>close()函数</h2><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;unistd.h&gt;</span></div><div class="line">int close(int fd);</div></pre></td></tr></table></figure></p>
<p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。<br>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;socket，什么是socket，我也不知道，之前有听过这个名词，但是没有去研究它。直到昨天一个同事问我，我们前台通过PHP将数据传给后台，是通过什么机制传数据的，前后台怎么进行通信的，后台又是怎么进行处理的，问的我真是一脸懵。于是在网上找了几篇觉得写得比较好的博客看了看，算是明白了一点。&lt;br&gt;我们先来看看socket的名词解释：&lt;br&gt;Socket的英文原义是“孔”或“插座”。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。&lt;br&gt;网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。&lt;br&gt;建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；&lt;br&gt;HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="socket" scheme="http://weibo.com/categories/socket/"/>
    
    
      <category term="socket" scheme="http://weibo.com/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：MVC和MVVM</title>
    <link href="http://weibo.com/2017/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AMVC%E5%92%8CMVVM/"/>
    <id>http://weibo.com/2017/08/21/设计模式：MVC和MVVM/</id>
    <published>2017-08-21T06:41:27.000Z</published>
    <updated>2017-08-21T09:08:20.874Z</updated>
    
    <content type="html"><![CDATA[<p>想起来写这篇文章主要是今天早上上班的途中，想到以前找工作的时候面试的一家单位说他们的使用的框架主要是AngularJs，然后就自然而然的想到了的MVC，什么是Angular后面一篇文章再写，这里就先把MVC和MVVM整明白。<br>看过很多文章写MVC的，然后一上来就是给你介绍什么是Model（数据模型–数据保存），什么是View（视图层–用户界面），什么是Controller（控制器–业务逻辑），再给你介绍他们之间的通信，看完之后基本上还是云里雾里。<br>先放几张在阮一峰老师的博客里贴的图，还是比较直观的介绍了什么是MVC：<br><img src="/2017/08/21/设计模式：MVC和MVVM/mvc_1.png" alt=""><br><a id="more"></a><br>通信方式（所有的通信都是单向的）：<br>1、View 发送指令到 Controller；<br>2、Controller 进行业务逻辑处理，要求 Model 改变状态；<br>3、Model 将新的数据发送到 View ， 用户得到反馈。</p>
<p>在接收用户指令是可以分为两种方式：<br><img src="/2017/08/21/设计模式：MVC和MVVM/mvc_2.png" alt=""><br>View 接收指令，然后传递给Controller，这也是工作中最常见的。<br>另外一种是直接通过Controller接受指令：<br><img src="/2017/08/21/设计模式：MVC和MVVM/mvc_3.png" alt=""><br>这种方式和服务器是对应的，因为服务器根本就没有View。<br>在服务器端，view根据model直接生成HTML，然后直接扔给浏览器去渲染和展示，通过Ajax或者js post告诉服务器controller view的响应事件，controller真的做的只是业务数据的处理，出来的结果其实还是数据，根本没有去做UI相关的事情。<br>MVC本质就是将数据展示和数据进行进行隔离，提高代码的复用性和扩展性。<br>接下来看一看下面这张图，更好的解释了MVC的之间的通信以及关系：<br><img src="/2017/08/21/设计模式：MVC和MVVM/mvc.png" alt=""><br>Controller可以和Model通信，也可以和View进行通信。<br>Controller和Model的关系：<br>绿色的箭头代表Controller可以直接进行对Model进行访问，也就是说Model对于Controller来说就是透明的。但是Model并不知道Controller是谁。如果Model发生了变化，那么就通过Notification和KVO的方式传递给Controller。<br>Controller和View的关系：<br>View对Controller来说就是透明的。Controller可以直接根据Model决定View的展示。View如果接受响应事件则通过delegate，target-action，block等方式告诉Controller的状态变化。Controller进行业务的处理，然后再控制View的展示。<br>到这里你会发现Model和View并不能直接的进行通信，都必须通过Controller。那这样Model和View就是相互独立的。<br>View只负责页面的展示，Model只是数据的存储，那么也就达到了解耦和重用的目的。<br>如果业务复杂起来，再加上其他乱七八糟的验证，controller就会变得很大，越来越难以维护。这个也是MVC比较明显的缺点。<br>在实际的项目开发中，往往采用更灵活的方式，阮一峰老师是这样解释的：<br><img src="/2017/08/21/设计模式：MVC和MVVM/mvc_4.png" alt=""></p>
<ol>
<li>用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</li>
<li>用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</li>
<li>Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。<br>同时阮一峰老师还说明了MVP和MVVM：<br><img src="/2017/08/21/设计模式：MVC和MVVM/mvp.png" alt=""></li>
<li>各部分之间的通信，都是双向的。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。<br><img src="/2017/08/21/设计模式：MVC和MVVM/mvvm_1.png" alt=""><br>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。<br>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。<br>可是我们为什么要采用MVVM这种设计模式呢？<br>原因是controller越来越臃肿，越来越难以维护，这就需要优化和瘦身了。所谓的业务逻辑，无非就是根据几个数据得出一个数据用来控制view的显示。比如展示的是什么文案，按钮能不能响应，页面能不能跳转等等。那MVVM就干了这件事，帮忙分担一下controller里面的部分业务逻辑。MVVM更合理的应该叫做MV-CM。<br><img src="/2017/08/21/设计模式：MVC和MVVM/mvvm.png" alt=""><br>这个时候，controller将不再直接和真实的model进行绑定了，而通过ViewModel,viewModel进行持有真实的Model。<br>关于MVVM的优点：<br>方便测试<br>在MVC下，Controller基本是无法测试的，里面混杂了个各种逻辑，而且分散在不同的地方。有了MVVM我们就可以测试里面的viewModel，来验证我们的处理结果对不对（Xcode7的测试已经越来越完善了）。<br>便于代码的移植<br>比如iOS里面有iPhone版本和iPad版本，除了交互展示不一样外，业务逻辑的model是一致的。这样，我们就可以以很小的代价去开发另一个app。<br>兼容MVC<br>MVVM是MVC的一个升级版，目前的MVC也可以很快的转换到MVVM这个模式。VC可以省去一大部分展示逻辑。<br>缺点：<br>类会增多<br>每个VC都附带一个viewModel，类的数量*2<br>viewModel会越来越庞大<br>我们把逻辑给了viewModel，那势必Model也会变得很复杂，里面的属性和方法越来越多。可能重写的方法比较多，因为涉及到一些数据的转换以及和controller之间的通信。<br>调用复杂度增加<br>由于数据都是从viewModel来，想想突然来了一个新人，一看代码，不知道真实的模型是谁。比如常用tableview的数据源，一般都是一个数组，如果不断的通过viewModel去取，沟通上没有那么直接。况且每封一层，意味着要写很多代码去融合他们的转换。</li>
</ol>
<p>参考文档：<br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a><br><a href="http://www.jianshu.com/p/f4faa720f00d" target="_blank" rel="external">http://www.jianshu.com/p/f4faa720f00d</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想起来写这篇文章主要是今天早上上班的途中，想到以前找工作的时候面试的一家单位说他们的使用的框架主要是AngularJs，然后就自然而然的想到了的MVC，什么是Angular后面一篇文章再写，这里就先把MVC和MVVM整明白。&lt;br&gt;看过很多文章写MVC的，然后一上来就是给你介绍什么是Model（数据模型–数据保存），什么是View（视图层–用户界面），什么是Controller（控制器–业务逻辑），再给你介绍他们之间的通信，看完之后基本上还是云里雾里。&lt;br&gt;先放几张在阮一峰老师的博客里贴的图，还是比较直观的介绍了什么是MVC：&lt;br&gt;&lt;img src=&quot;/2017/08/21/设计模式：MVC和MVVM/mvc_1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://weibo.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="mvc,mvvm" scheme="http://weibo.com/tags/mvc-mvvm/"/>
    
  </entry>
  
  <entry>
    <title>5种跨域方式以及原理</title>
    <link href="http://weibo.com/2017/08/19/5%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <id>http://weibo.com/2017/08/19/5种跨域方式以及原理/</id>
    <published>2017-08-19T08:05:30.000Z</published>
    <updated>2017-08-19T08:56:53.657Z</updated>
    
    <content type="html"><![CDATA[<p>如果想从浏览器的一个网站访问去执行另外一个网站的脚本，显然是不可行的，因为受到了浏览器同源策略的影响，同源策略是浏览器对JavaScript施加的安全限制。<br>同源策略：如果两个页面拥有相同的协议（protocol），端口（port，如果指定）和主机（host），那么这两个页面就属于同一个源（origin）。<br>如果想要通过浏览器中的一个页面去执行另一个页面的脚本，那么就需要通过跨域。<br>下面介绍几种常见的跨域方式：</p>
<h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>script标签是不受同源策略的影响的，它可以引入来自任何地方的js文件。<br>jsonp的原理就是在客户端和服务端定义一个函数，当客户端发起一个请求时，服务端返回一段javascript代码，其中调用了在客户端定义的函数，并将相应的数据作为参数传入该函数。<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> jsonp_cb(data) &#123;</div><div class="line">    console.log(data);</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">ajax</span></span>()&#123;</div><div class="line">    var url = <span class="string">"http://xx.com/test.php?jsonp_callback=jsonp_cb"</span>;</div><div class="line">    var script = document.createElement(<span class="string">'script'</span>);</div><div class="line">    // 发送请求</div><div class="line">    script.src = url;</div><div class="line">    document.head.appendChild(script);</div><div class="line">&#125;</div><div class="line">ajax()</div></pre></td></tr></table></figure></p>
<p>服务端获取到jsonp_callback传递的函数名jsonp_cb，返回一段对该函数调用的js代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jsonp_cb(&#123;</div><div class="line">   <span class="string">"name"</span>: <span class="string">"story"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="img-ping"><a href="#img-ping" class="headerlink" title="img ping"></a>img ping</h2><p>img标签也是没有跨域限制的，但它只能用来发送GET请求，且无法获取服务端的响应文本，可以利用它实现一些简单的、单向的跨域通信，例如跟踪用户的点击<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var img = new Image();</div><div class="line">img.onload = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    console.log(<span class="string">'done'</span>)</div><div class="line">    img.onload = null;</div><div class="line">    img = null;</div><div class="line">&#125;</div><div class="line">img.src = <span class="string">"http://xx/xx.gif"</span></div></pre></td></tr></table></figure></p>
<h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><p>window对象拥有name属性，它有一个特点：相同协议下，在一个页面中，不随URL的改变而改变。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.name = <span class="string">'string'</span> // 字符串，一般允许的最大值为2M</div><div class="line">console.log(window.name)</div><div class="line">location = <span class="string">'http://funteas.com/'</span></div></pre></td></tr></table></figure></p>
<p>此时，在控制台输入window.name，结果依然是”string”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.name // <span class="string">"string"</span></div></pre></td></tr></table></figure></p>
<p>window.name的值只能是字符串，任何其他类型的值都会“转化”为字符串<br>例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.name = <span class="function"><span class="title">function</span></span>()&#123;&#125;</div><div class="line">console.log(window.name)</div><div class="line">// <span class="string">"function()&#123;&#125;"</span></div></pre></td></tr></table></figure></p>
<p>通过window.name实现跨域也很简单，iframe拥有contentWindow属性，其指向该iframe的window对象的引用，如果在iframe的src指向的页面中设置window.name值，那么就可以通过iframe.contentWindow.name就可以拿到这个值了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var url = <span class="string">"http://funteas.com/lab/windowName"</span>;</div><div class="line">var iframe = document.createElement(<span class="string">'iframe'</span>)</div><div class="line">iframe.onload = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    var data = iframe.contentWindow.name</div><div class="line">    console.log(data)</div><div class="line">&#125;</div><div class="line">iframe.src = url</div><div class="line">document.body.appendChild(iframe)</div></pre></td></tr></table></figure></p>
<p>然而，chrome会提示你跨域了！<br>而我们已经知道window.name不随URL的改变而改版，也就是说，onload时，已经获取到了name，只不过因为不同源，当前页面的脚本无法拿到iframe.contentWindow.name，此时只需要把iframe.src改为同源即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var url = <span class="string">"http://funteas.com/lab/windowName"</span>;</div><div class="line">var iframe = document.createElement(<span class="string">'iframe'</span>)</div><div class="line">iframe.onload = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    iframe.src = <span class="string">'favicon.ico'</span>;</div><div class="line">    var data = iframe.contentWindow.name</div><div class="line">    console.log(data)</div><div class="line">&#125;</div><div class="line">iframe.src = url</div><div class="line">document.body.appendChild(iframe)</div></pre></td></tr></table></figure></p>
<p>刷新页面，你会发现iframe不断刷新，这是因为每次onload，iframe的src被修改，然后再次触发onload，从而导致iframe循环刷新，修改下即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var url = <span class="string">"http://funteas.com/lab/windowName"</span>;</div><div class="line">var iframe = document.createElement(<span class="string">'iframe'</span>)</div><div class="line">var state = <span class="literal">true</span>;</div><div class="line">iframe.onload = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    <span class="keyword">if</span>(state === <span class="literal">true</span>)&#123;</div><div class="line">        iframe.src = <span class="string">'favicon.ico'</span>;</div><div class="line">        state = <span class="literal">false</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state === <span class="literal">false</span>)&#123;</div><div class="line">        state = null</div><div class="line">        var data = iframe.contentWindow.name</div><div class="line">        console.log(data)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">iframe.src = url</div><div class="line">document.body.appendChild(iframe)</div></pre></td></tr></table></figure></p>
<p>上面请求的是一个静态页面，而服务端通常需要的是动态数据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">'&lt;script&gt; window.name = "&#123;\"name\":\"story\"&#125;"&lt;/script&gt;'</span>;</div></pre></td></tr></table></figure></p>
<h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>postMessage允许不同源之间的脚本进行通信，用法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otherWindow.postMessage(message, targetOrigin);</div></pre></td></tr></table></figure></p>
<p>otherWindow 引用窗口 iframe.contentwindow 或 window.open返回的对象<br>message 为要传递的数据<br>targetOrigin 为目标源<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// http://127.0.0.1:80</div><div class="line">var iframe = document.createElement(<span class="string">'iframe'</span>)</div><div class="line">iframe.onload = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">    var popup = iframe.contentWindow</div><div class="line">    popup.postMessage(<span class="string">"hello"</span>, <span class="string">"http://127.0.0.1:5000"</span>);</div><div class="line">&#125;</div><div class="line">iframe.src = <span class="string">'http://127.0.0.1:5000/lab/postMessage'</span></div><div class="line">document.body.appendChild(iframe)</div><div class="line">// 监听返回的postMessage</div><div class="line">window.addEventListener(<span class="string">"message"</span>, <span class="keyword">function</span>(event)&#123;</div><div class="line">    <span class="keyword">if</span> (event.origin !== <span class="string">"http://127.0.0.1:5000"</span>) <span class="built_in">return</span>;</div><div class="line">    console.log(event.data)</div><div class="line">&#125;, <span class="literal">false</span>)</div><div class="line">// http://127.0.0.1:5000/lab/postMessage</div><div class="line">window.addEventListener(<span class="string">"message"</span>, <span class="keyword">function</span>(event)&#123;</div><div class="line">    // 验证消息来源</div><div class="line">    <span class="keyword">if</span> (event.origin !== <span class="string">"http://127.0.0.1"</span>) <span class="built_in">return</span>;</div><div class="line">    console.log(event.source); // 消息源 popup</div><div class="line">    console.log(event.origin); // 消息源URI https://secure.example.net </div><div class="line">    console.log(event.data); // 来自消息源的数据 hello</div><div class="line">    // 返回数据</div><div class="line">    var message = <span class="string">'world'</span>;</div><div class="line">    event.source.postMessage(message, event.origin);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure></p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS（跨域资源共享）是一种跨域访问的机制，可以让AJAX实现跨域访问。它允许一个域上的脚本向另一个域提交跨域 AJAX 请求。实现此功能非常简单，只需由服务器发送一个响应标头即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: * // 允许来自任何域的请求</div><div class="line">Access-Control-Allow-Origin: http://funteas.com/ // 仅允许来自http://</div></pre></td></tr></table></figure></p>
<p>funteas.com/的请求<br>当客户端的ajax请求的url为其他域时，对于支持CORS的浏览器，请求头会自动添加Origin，值为当前host<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">var url = <span class="string">'http://bar.other/resources/public-data/'</span>;</div><div class="line">xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line">xhr.send();</div></pre></td></tr></table></figure></p>
<p>CORS默认不发送cookie，如果要发送cookie，需要设置withCredentials<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.withCredentials = <span class="literal">true</span>;</div></pre></td></tr></table></figure></p>
<p>同时，服务端也要设置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果想从浏览器的一个网站访问去执行另外一个网站的脚本，显然是不可行的，因为受到了浏览器同源策略的影响，同源策略是浏览器对JavaScript施加的安全限制。&lt;br&gt;同源策略：如果两个页面拥有相同的协议（protocol），端口（port，如果指定）和主机（host），那么这两个页面就属于同一个源（origin）。&lt;br&gt;如果想要通过浏览器中的一个页面去执行另一个页面的脚本，那么就需要通过跨域。&lt;br&gt;下面介绍几种常见的跨域方式：&lt;/p&gt;
&lt;h2 id=&quot;jsonp&quot;&gt;&lt;a href=&quot;#jsonp&quot; class=&quot;headerlink&quot; title=&quot;jsonp&quot;&gt;&lt;/a&gt;jsonp&lt;/h2&gt;&lt;p&gt;script标签是不受同源策略的影响的，它可以引入来自任何地方的js文件。&lt;br&gt;jsonp的原理就是在客户端和服务端定义一个函数，当客户端发起一个请求时，服务端返回一段javascript代码，其中调用了在客户端定义的函数，并将相应的数据作为参数传入该函数。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://weibo.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP如何传递多层不同类型的变量</title>
    <link href="http://weibo.com/2017/08/19/PHP%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%A4%9A%E5%B1%82%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F/"/>
    <id>http://weibo.com/2017/08/19/PHP如何传递多层不同类型的变量/</id>
    <published>2017-08-19T06:57:42.000Z</published>
    <updated>2017-08-19T07:51:09.220Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题是上次做网络攻击检测配置时候遇到的一个问题，当时问题是这样的，异常包攻击检测的时候需要配置IP地址，IP范围以及子网地址，后台给我的接口是这样的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;ipaddr_items&gt;</div><div class="line">    &lt;<span class="built_in">type</span>&gt;subnet&lt;/<span class="built_in">type</span>&gt;</div><div class="line">    &lt;address&gt;192.168.199.0/24&lt;/address&gt;</div><div class="line">&lt;/ipaddr_items&gt;</div><div class="line">&lt;ipaddr_items&gt;</div><div class="line">    &lt;<span class="built_in">type</span>&gt;range&lt;/<span class="built_in">type</span>&gt;</div><div class="line">    &lt;address&gt;192.168.199.1-192.168.199.254&lt;/address&gt;</div><div class="line">&lt;/ipaddr_items&gt;</div><div class="line">&lt;ipaddr_items&gt;</div><div class="line">    &lt;<span class="built_in">type</span>&gt;host&lt;/<span class="built_in">type</span>&gt;</div><div class="line">    &lt;address&gt;192.168.199.10&lt;/address&gt;</div><div class="line">&lt;/ipaddr_items&gt;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>平常我传递最多的只是传递一层的接口数据，而这里有两层，而且第二层数据还有两种不同的接口，当时确实不知道怎么做，后来想到这样一种方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="variable">$param</span>[<span class="string">'ipaddr_items'</span>] = array(</div><div class="line">    array(</div><div class="line">        <span class="string">'type'</span>=&gt;<span class="string">'subnet'</span>,</div><div class="line">        <span class="string">'address'</span> =&gt; <span class="string">'192.168.199.0/24'</span></div><div class="line">    ),</div><div class="line">    array(</div><div class="line">        <span class="string">'type'</span>=&gt;<span class="string">'range'</span>,</div><div class="line">        <span class="string">'address'</span> =&gt; <span class="string">'192.168.199.1-192.168.199.254'</span></div><div class="line">    ),</div><div class="line">    array(</div><div class="line">        <span class="string">'type'</span>=&gt;<span class="string">'host'</span>,</div><div class="line">        <span class="string">'address'</span> =&gt; <span class="string">'192.168.199.10'</span></div><div class="line">    ),</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>这样数据确实可以传给C后台，但是我传过去的只是写死的数据，不能通过配置框进行自由配置，这样肯定是不行的。<br>那应该怎么样才能把自由配置的数据传给后台进行显示，只能通过配置的数据上想办法了。于是有了下面这样一种方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">'ipaddr_items'</span>])&#123;</div><div class="line">    <span class="variable">$ipaddr_items</span> = explode(<span class="string">','</span>,formatpost(<span class="variable">$_POST</span>[<span class="string">'ipaddr_items'</span>]));</div><div class="line">    <span class="keyword">if</span>(count(<span class="variable">$ipaddr_items</span>)&gt;0)&#123;</div><div class="line">        foreach(<span class="variable">$ipaddr_items</span> as <span class="variable">$k</span>=&gt;<span class="variable">$v</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(strstr(<span class="variable">$v</span>, <span class="string">'-'</span>))&#123;</div><div class="line">                <span class="variable">$data_temp</span>[<span class="variable">$k</span>][<span class="string">'type'</span>] = <span class="string">'range'</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(strstr(<span class="variable">$v</span>, <span class="string">'/'</span>))&#123;</div><div class="line">                <span class="variable">$data_temp</span>[<span class="variable">$k</span>][<span class="string">'type'</span>] = <span class="string">'subnet'</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="variable">$data_temp</span>[<span class="variable">$k</span>][<span class="string">'type'</span>] = <span class="string">'host'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="variable">$data_temp</span>[<span class="variable">$k</span>][<span class="string">'address'</span>] = <span class="variable">$v</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="variable">$data_temp</span>[0] = formatpost(<span class="variable">$_POST</span>[<span class="string">'ipaddr_items'</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="variable">$param</span>[<span class="string">'ipaddr_items'</span>] = <span class="variable">$data_temp</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先通过explode()函数将以逗号分隔字符串打散成数组，然后对数组包含的数据进行判断；<br>如果数量大于0，则对数组进行遍历，如果等于0，直接进行格式化；<br>此时又要进行第二重判断，对类型进行判断，通过strstr()函数来判断一个字符串中是否含有另外一种字符串，此处也就是判断类型，通过三种类型的特征判定完毕之后就可以进行赋值了。<br>验证过程此处就不写了，结果是可以将配置框配置进去的数据传到后台，然后正常显示到页面上。<br>注：上面提到了explode()函数，与之对应的还有implode()函数，作用是将数组元素组合成字符串。参见下面的的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( <span class="variable">$get_url_param</span> == <span class="string">'sec_ipdefend_show'</span>)&#123;</div><div class="line">/*Get model, send msg to system*/</div><div class="line">    <span class="variable">$rspString</span> = getResponse( <span class="variable">$moduleName</span>, <span class="string">"show"</span> , <span class="variable">$param</span>, <span class="variable">$demo_link</span>=<span class="string">'sec_ipdefend_show'</span> );</div><div class="line">    <span class="variable">$res</span> = getAssign(<span class="variable">$rspString</span>,0);</div><div class="line">    <span class="variable">$param</span> = <span class="variable">$res</span>[<span class="string">'group'</span>][0];</div><div class="line">    <span class="keyword">if</span>(<span class="variable">$param</span>[<span class="string">'ipaddr_items'</span>])&#123;</div><div class="line">        foreach(<span class="variable">$param</span>[<span class="string">'ipaddr_items'</span>] as <span class="variable">$k</span>=&gt;<span class="variable">$v</span>)&#123;</div><div class="line">            <span class="variable">$ipaddr_items</span>[<span class="variable">$k</span>] = <span class="variable">$v</span>[<span class="string">'address'</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="variable">$param</span>[<span class="string">'ipaddr_items'</span>] = implode(<span class="string">','</span>,<span class="variable">$ipaddr_items</span>);</div><div class="line">    file_put_contents(<span class="string">'b.txt'</span>,json_encode(<span class="variable">$param</span>));</div><div class="line">    include template(<span class="string">'sec_ipdefend_show'</span>);</div><div class="line">    <span class="built_in">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个问题是上次做网络攻击检测配置时候遇到的一个问题，当时问题是这样的，异常包攻击检测的时候需要配置IP地址，IP范围以及子网地址，后台给我的接口是这样的。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ipaddr_items&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;&amp;gt;subnet&amp;lt;/&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;address&amp;gt;192.168.199.0/24&amp;lt;/address&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ipaddr_items&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ipaddr_items&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;&amp;gt;range&amp;lt;/&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;address&amp;gt;192.168.199.1-192.168.199.254&amp;lt;/address&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ipaddr_items&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ipaddr_items&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;&amp;gt;host&amp;lt;/&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;address&amp;gt;192.168.199.10&amp;lt;/address&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ipaddr_items&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="php" scheme="http://weibo.com/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP如何与C进行数据交互</title>
    <link href="http://weibo.com/2017/08/19/PHP%E5%A6%82%E4%BD%95%E4%B8%8EC%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
    <id>http://weibo.com/2017/08/19/PHP如何与C进行数据交互/</id>
    <published>2017-08-19T03:29:30.000Z</published>
    <updated>2017-08-19T06:27:47.276Z</updated>
    
    <content type="html"><![CDATA[<p>今天同事问我，我们前台是如何传递数据给C，通过什么参数和方法。C又是通过什么机制进行接收前台传递过来的数据。我在代码上瞄了瞄，还是没有搞懂C是如何进行数据处理，这个问题留到后面再讲。接下来讲讲我们前台通过PHP是如何获取C的数据，然后进行页面展示的。<br>先上一段代码，待会儿再分析：<br><img src="/2017/08/19/PHP如何与C进行数据交互/code_1.png" alt=""><br><a id="more"></a></p>
<h2 id="PHP交互处理流程"><a href="#PHP交互处理流程" class="headerlink" title="PHP交互处理流程"></a>PHP交互处理流程</h2><h3 id="参数介绍："><a href="#参数介绍：" class="headerlink" title="参数介绍："></a>参数介绍：</h3><pre><code>POST: submit_post(对应变量名：$post_submit_action)
GET:  g(对应变量名：$get_url_param)
</code></pre><h4 id="通过参数-get-url-param进行交互"><a href="#通过参数-get-url-param进行交互" class="headerlink" title="通过参数$get_url_param进行交互"></a>通过参数$get_url_param进行交互</h4><p>模块入口在indexmods文件夹中的.mod文件中，通过参数$get_url_param进行判断，然后加载对应的modules文件夹中的.mds文件，同样是通过参数$get_url_param进行数据交互处理，最后显示在页面上。<br>简单流程如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">html --&gt; <span class="variable">$get_url_param</span> --&gt; mod --&gt; mds(<span class="variable">$get_url_param</span>) --&gt; html</div></pre></td></tr></table></figure></p>
<h4 id="通过参数-post-submit-action进行交互"><a href="#通过参数-post-submit-action进行交互" class="headerlink" title="通过参数$post_submit_action进行交互"></a>通过参数$post_submit_action进行交互</h4><p>$post_submit_action原理与$get_url_param一样，但是submit_post有的情况不需要通过.mod进行判断，直接在.mds文件中进行处理，最后显示在页面上。<br>简单流程如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">html --&gt; <span class="variable">$post_submit_action</span> --&gt; mod --&gt; mds(<span class="variable">$post_submit_action</span>) --&gt; html</div></pre></td></tr></table></figure></p>
<h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><h4 id="getResponse-方法："><a href="#getResponse-方法：" class="headerlink" title="getResponse()方法："></a>getResponse()方法：</h4><p>通过C提供的接口(模块名)和方法获取XML数据。<br>语法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$rspString</span> = getResponse(<span class="string">'接口名称'</span>, <span class="string">'方法'</span>, <span class="string">'参数'</span>);</div></pre></td></tr></table></figure></p>
<p>接口名称：字符串(C开发人员提供)<br>方法：    字符串(接口的调用方法，C开发人员提供)<br>参数：    数组(接口所需要的各个字段，与C开发人员进行对接)</p>
<h4 id="getAssign-方法："><a href="#getAssign-方法：" class="headerlink" title="getAssign()方法："></a>getAssign()方法：</h4><p>对getResponse()获取的数据进行格式化。<br>语法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$rsp_arr</span> = getAssign(<span class="variable">$rspString</span>, json:0);</div></pre></td></tr></table></figure></p>
<p>json:0 是对数据进行json数据格式化。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>之前贴的一张图来说：<br>$param[‘…’]为前台需要获取的字段<br>$_GET 或者 $_POST是请求方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file_put_contents(<span class="string">'001.txt'</span>,json_encode(<span class="variable">$param</span>));</div></pre></td></tr></table></figure></p>
<p>这个方法是PHP里用于生成数据文件的方法，通过这个方法可以查看从后台获取json格式的数据文件，也可以查看传递给后台json格式的数据文件，以及各种参数。用来调试十分方便。</p>
<h3 id="PHP的isset-函数"><a href="#PHP的isset-函数" class="headerlink" title="PHP的isset()函数"></a>PHP的isset()函数</h3><p>一般用来检测变量是否设置<br>格式：<br>bool isset ( mixed var [, mixed var [, …]] )<br>功能：<br>检测变量是否设置<br>返回值：<br>若变量不存在则返回 FALSE<br>若变量存在且其值为NULL，也返回 FALSE<br>若变量存在且值不为NULL，则返回 TURE<br>同时检查多个变量时，每个单项都符合上一条要求时才返回 TRUE，否则结果为 FALSE<br>更多说明：<br>使用 unset() 释放变量之后，它将不再是 isset()。<br>PHP函数isset()只能用于变量，传递任何其它参数都将造成解析错误。<br>检测常量是否已设置可使用 defined() 函数。 </p>
<h3 id="PHP的empty-函数"><a href="#PHP的empty-函数" class="headerlink" title="PHP的empty()函数"></a>PHP的empty()函数</h3><p>判断值为否为空<br>格式：bool empty ( mixed var )<br>功能：检查一个变量是否为空<br>返回值：<br>若变量不存在则返回 TRUE<br>若变量存在且其值为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 TURE<br>若变量存在且值不为””、0、”0”、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 FALSE<br>更多说明：<br>empty()的返回值=!(boolean) var，但不会因为变量未定义而产生警告信息。参见转换为布尔值获取更多信息。<br>empty() 只能用于变量，传递任何其它参数都将造成Paser error而终止运行。<br>检测常量是否已设置可使用 defined() 函数。</p>
<h2 id="json-decode-—-对-JSON-格式的字符串进行编码"><a href="#json-decode-—-对-JSON-格式的字符串进行编码" class="headerlink" title="json_decode — 对 JSON 格式的字符串进行编码"></a>json_decode — 对 JSON 格式的字符串进行编码</h2><h2 id="json-encode-—-对变量进行-JSON-编码"><a href="#json-encode-—-对变量进行-JSON-编码" class="headerlink" title="json_encode — 对变量进行 JSON 编码"></a>json_encode — 对变量进行 JSON 编码</h2><p>json_encode()和json_decode()是编译和反编译过程，注意json只接受utf-8编码的字符，所以json_encode()的参数必须是utf-8编码，否则会得到空字符或者null。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天同事问我，我们前台是如何传递数据给C，通过什么参数和方法。C又是通过什么机制进行接收前台传递过来的数据。我在代码上瞄了瞄，还是没有搞懂C是如何进行数据处理，这个问题留到后面再讲。接下来讲讲我们前台通过PHP是如何获取C的数据，然后进行页面展示的。&lt;br&gt;先上一段代码，待会儿再分析：&lt;br&gt;&lt;img src=&quot;/2017/08/19/PHP如何与C进行数据交互/code_1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="php,c" scheme="http://weibo.com/categories/php-c/"/>
    
    
      <category term="php,html,c" scheme="http://weibo.com/tags/php-html-c/"/>
    
  </entry>
  
  <entry>
    <title>使用 vue-cli 搭建项目</title>
    <link href="http://weibo.com/2017/08/17/%E4%BD%BF%E7%94%A8-vue-cli-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <id>http://weibo.com/2017/08/17/使用-vue-cli-搭建项目/</id>
    <published>2017-08-17T01:56:36.000Z</published>
    <updated>2017-08-17T02:49:23.078Z</updated>
    
    <content type="html"><![CDATA[<p>在这里向大家介绍一下如何在十分钟之内使用vue-cli搭建自己的项目，步骤和搭建node.js项目有一定的相似性。只是到了最后安装依赖的时候踩了一个坑。待我细细讲来。哈哈~<br>首先介绍一下什么是Vue.js：<br>Vue是一个前端框架，它有两大特点：数据绑定、组件化</p>
<h2 id="什么是数据绑定？"><a href="#什么是数据绑定？" class="headerlink" title="什么是数据绑定？"></a>什么是数据绑定？</h2><p>比如改变一个Input输入框的值，会[自动同步]更新页面上其他绑定该Input输入框的组件的值。<br><img src="/2017/08/17/使用-vue-cli-搭建项目/data_bind.png" alt=""></p>
<h2 id="什么是组件化？"><a href="#什么是组件化？" class="headerlink" title="什么是组件化？"></a>什么是组件化？</h2><p>页面上小到一个按钮都可以是一个单独的文件.vue(俗称组件)，这些组件就像乐高积木一样可以通过互相引用组装起来。<br><img src="/2017/08/17/使用-vue-cli-搭建项目/components.png" alt=""><br>好啦，现在开始如何搭建项目吧！<br><a id="more"></a></p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>这个在之前的项目搭建中已经有过介绍，此处不再赘述。</p>
<h2 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h2><p>全局安装vue-cli<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g vue-cli</div></pre></td></tr></table></figure></p>
<p>上面这种方式加载的是国外资源，可能比较慢，所以需要加在国内镜像，我一般使用淘宝镜像，首先设置cnpm：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure></p>
<p>如果安装失败，可以使用 npm cache clean 清理缓存，然后再重新安装。后面的安装过程中，如有安装失败的情况，也需要先清理缓存。<br>同样可以使用 cnpm -v 查看是否安装成功。<br>然后就可以使用一下命令安装 vue-cli 和 webpack 了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install -g vue-cli</div></pre></td></tr></table></figure></p>
<p>在这里可以不安装webpack，因为在最新的 vue 项目模板中都带有 webpack 。<br>可以使用 vue -V 来查看 vue-cli 是否安装成功。<br>如果提示”无法识别 ‘vue’ “，有可能是 npm 版本过低，可以使用 npm install -g npm 来更新版本。</p>
<h2 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h2><p>首先要在命令行中通过 cd 进入到项目目录，然后执行以下命令，用来初始化下项目：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vue init webpack Vue-Project</div></pre></td></tr></table></figure></p>
<p>webpack<br>是模板名称，可以到 vue.js 的 GitHub 上查看更多的模板<a href="https://github.com/vuejs-templates" target="_blank" rel="external">https://github.com/vuejs-templates</a><br>Vue-Project 是自定义的项目名称，命令执行之后，会在当前目录生成一个以该名称命名的项目文件夹。<br><img src="/2017/08/17/使用-vue-cli-搭建项目/project_name.png" alt=""><br>配置完成后，可以看到目录下多出了一个项目文件夹，里面就是 vue-cli 创建的一个基于 webpack 的 vue.js 项目<br>然后进入项目目录（cd Vue-Project），使用 cnpm 安装依赖：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install</div></pre></td></tr></table></figure></p>
<p>还记得我前面说过的坑吧！在这里运行命令后，可能会报错，就像这种：<br><img src="/2017/08/17/使用-vue-cli-搭建项目/error.png" alt=""><br>当时尝试了这些方法：重新安装淘宝镜像，不行。使用 npm install 安装，不行。重新生成项目，还是不行。到底是什么原因呢？<br>没错，就是项目下 node_modules 这个文件夹捣鬼，因为这些模块都是之前在生成项目时就已经安装好了的，会对后面安装依赖造成冲突，所以将项目文件下的 node_modules 给整个删除，然后再使用 cnpm install 重新安装依赖就可以安装成功了！<br>接下来就是启动项目了，运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run dev</div></pre></td></tr></table></figure></p>
<p><img src="/2017/08/17/使用-vue-cli-搭建项目/run_dev.png" alt=""><br>接下来就可以在浏览器里面看到 vue 漂亮的页面了。<br><img src="/2017/08/17/使用-vue-cli-搭建项目/page.png" alt=""><br>以上就是整个搭建步骤啦。<br>如果浏览器打开之后，没有加载出页面，有可能是本地的 8080 端口被占用，需要修改一下配置文件 config&gt;index.js<br><img src="/2017/08/17/使用-vue-cli-搭建项目/config_port.png" alt=""><br>建议将端口号改为不常用的端口。另外我还将 build 的路径前缀修改为 ‘ ./ ‘（原本为 ‘ / ‘），是因为打包之后，外部引入 js 和 css 文件时，如果路径以 ‘ / ‘ 开头，在本地是无法找到对应文件的（服务器上没问题）。所以如果需要在本地打开打包后的文件，就得修改文件路径。</p>
<h2 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h2><p>自己的项目文件都需要放到 src 文件夹下。<br>项目开发完成之后，可以输入 npm run build 来进行打包工作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run build</div></pre></td></tr></table></figure></p>
<p>打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看。<br>项目上线时，只需要将 dist 文件夹放到服务器就行了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这里向大家介绍一下如何在十分钟之内使用vue-cli搭建自己的项目，步骤和搭建node.js项目有一定的相似性。只是到了最后安装依赖的时候踩了一个坑。待我细细讲来。哈哈~&lt;br&gt;首先介绍一下什么是Vue.js：&lt;br&gt;Vue是一个前端框架，它有两大特点：数据绑定、组件化&lt;/p&gt;
&lt;h2 id=&quot;什么是数据绑定？&quot;&gt;&lt;a href=&quot;#什么是数据绑定？&quot; class=&quot;headerlink&quot; title=&quot;什么是数据绑定？&quot;&gt;&lt;/a&gt;什么是数据绑定？&lt;/h2&gt;&lt;p&gt;比如改变一个Input输入框的值，会[自动同步]更新页面上其他绑定该Input输入框的组件的值。&lt;br&gt;&lt;img src=&quot;/2017/08/17/使用-vue-cli-搭建项目/data_bind.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是组件化？&quot;&gt;&lt;a href=&quot;#什么是组件化？&quot; class=&quot;headerlink&quot; title=&quot;什么是组件化？&quot;&gt;&lt;/a&gt;什么是组件化？&lt;/h2&gt;&lt;p&gt;页面上小到一个按钮都可以是一个单独的文件.vue(俗称组件)，这些组件就像乐高积木一样可以通过互相引用组装起来。&lt;br&gt;&lt;img src=&quot;/2017/08/17/使用-vue-cli-搭建项目/components.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;好啦，现在开始如何搭建项目吧！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vue.js" scheme="http://weibo.com/categories/vue-js/"/>
    
    
      <category term="vue2.0" scheme="http://weibo.com/tags/vue2-0/"/>
    
  </entry>
  
  <entry>
    <title>RESTful(表述性状态转移)</title>
    <link href="http://weibo.com/2017/08/16/RESTful%EF%BC%88%E8%A1%A8%E8%BF%B0%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%EF%BC%89/"/>
    <id>http://weibo.com/2017/08/16/RESTful（表述性状态转移）/</id>
    <published>2017-08-16T11:25:55.000Z</published>
    <updated>2017-08-17T02:49:14.012Z</updated>
    
    <content type="html"><![CDATA[<p>REST是英文Representational State Transfer的缩写，中文称之为“表述性状态转移”<br>基于HTTP协议<br>是另一种服务架构<br>传递是JSON、POX（Plain Old XML）而不是SOAP格式的数据<br>充分利用HTTP谓词（Verb）<br>侧重数据的传输，业务逻辑交给客户端自行处理<br>REST是一种分布式服务架构的风格约束，像Java、.Net（WCF、WebAPI）都有对该约束的实现，使URL变得更加有意义，更加简洁明了，如：<br><a href="http://heaxen.github.io/products/1" target="_blank" rel="external">http://heaxen.github.io/products/1</a> get请求 表示获得所有产品的第1个<br><a href="http://heaxen.github.io/products/product" target="_blank" rel="external">http://heaxen.github.io/products/product</a> post请求 表示添加一个产品<br><a href="http://heaxen.github.io/products/1/price" target="_blank" rel="external">http://heaxen.github.io/products/1/price</a> get请求 表示获得第1个产品的价格<br><a href="http://heaxen.github.io/products/1" target="_blank" rel="external">http://heaxen.github.io/products/1</a> delete请求 删除编号为1的产品</p>
<h2 id="REST设计需要遵循的原则"><a href="#REST设计需要遵循的原则" class="headerlink" title="REST设计需要遵循的原则"></a>REST设计需要遵循的原则</h2><p>网络上的所有事物都被抽象为资源（resource）；<br>每个资源对应一个唯一的资源标识符（resource identifier）；<br>通过通用的连接器接口（generic connector interface）对资源进行操作；<br>对资源的各种操作不会改变资源标识符；<br>所有的操作都是无状态的（stateless）</p>
<h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>GET<br>表示查询操作，相当于Retrieve、Select操作<br>POST<br>表示插入操作，相当于Create，Insert操作<br>PUT<br>表示修改操作，相当于Update操作<br>DELETE<br>表示删除操作，相当于Delete操作<br><a id="more"></a><br>NodeJS+Express可以很容易的实现REST<br>application/x-www-form-urlencoded<br>multipart/form-data<br>application/json<br>res.setHeader(‘Content-Type’, ‘application/json;charset=utf-8’);  </p>
<p>cars.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">var express = require(<span class="string">'express'</span>);</div><div class="line">var router = express.Router();</div><div class="line">var _= require(<span class="string">'lodash'</span>);</div><div class="line"></div><div class="line">var cars=[];</div><div class="line">cars.push(&#123;id:201701,name:<span class="string">"BMW"</span>,price:190,speed:<span class="string">"210km/h"</span>,color:<span class="string">"白色"</span>&#125;);</div><div class="line">cars.push(&#123;id:201702,name:<span class="string">"BYD"</span>,price:25,speed:<span class="string">"160km/h"</span>,color:<span class="string">"红色"</span>&#125;);</div><div class="line">cars.push(&#123;id:201703,name:<span class="string">"Benz"</span>,price:300,speed:<span class="string">"215km/h"</span>,color:<span class="string">"蓝色"</span>&#125;);</div><div class="line">cars.push(&#123;id:201704,name:<span class="string">"Honda"</span>,price:190,speed:<span class="string">"170km/h"</span>,color:<span class="string">"黑色"</span>&#125;);</div><div class="line">cars.push(&#123;id:201705,name:<span class="string">"QQ"</span>,price:130,speed:<span class="string">"210km/h"</span>,color:<span class="string">"白色"</span>&#125;);</div><div class="line"></div><div class="line">/* Get */</div><div class="line">/*获得所有汽车*/</div><div class="line">/*url /cars/*/</div><div class="line">router.get(<span class="string">'/'</span>, <span class="keyword">function</span>(req, res, next) &#123;</div><div class="line">    res.json(cars);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">/*Get*/</div><div class="line">/*获得汽车通过id*/</div><div class="line">/*url：/cars/:id  */</div><div class="line">router.get(<span class="string">'/:id'</span>, <span class="keyword">function</span>(req, res, next) &#123;</div><div class="line">     //从路径中映射参数，转换成数字</div><div class="line">      var id=parseInt(req.params.id);</div><div class="line">      var car=_.find(cars,&#123;id:id&#125;);</div><div class="line">      res.json(car);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">/*Post*/</div><div class="line">/*添加汽车*/</div><div class="line">/*url：/cars/car  */</div><div class="line">router.post(<span class="string">'/car'</span>, <span class="keyword">function</span>(req, res, next) &#123;</div><div class="line">      var car=req.body;  //从请求正文中获得json对象</div><div class="line">      car.id=_.last(cars).id+1;  //将编号修改为最后一辆车的编号+1</div><div class="line">      cars.push(car);  //将汽车对象添加到集合中</div><div class="line">      res.json(car);  //将添加成功的车以json的形式返回</div><div class="line">&#125;);</div><div class="line"></div><div class="line">/*Put*/</div><div class="line">/*修改汽车*/</div><div class="line">/*url：/cars/car  */</div><div class="line">router.put(<span class="string">'/car'</span>, <span class="keyword">function</span>(req, res, next) &#123;</div><div class="line">      var car=req.body;  //从请求正文中获得json对象</div><div class="line">      console.log(req.body);</div><div class="line">      var index=_.findIndex(cars,&#123;id:parseInt(car.id)&#125;);  //根据id获得车在集合中的下标</div><div class="line">      </div><div class="line">      cars[index]=car;  //替换原对象</div><div class="line">      //res.json(car);  //将修改后的车以json的形式返回</div><div class="line">      res.send(&#123;status:<span class="string">"success"</span>, message:<span class="string">"更新成功!"</span>&#125;);  </div><div class="line">&#125;);</div><div class="line"></div><div class="line">/*Delete*/</div><div class="line">/*删除汽车*/</div><div class="line">/*url：/cars/:id  */</div><div class="line">router.delete(<span class="string">'/id/:id'</span>, <span class="keyword">function</span>(req, res, next) &#123;</div><div class="line">      //获得url中的编号参数</div><div class="line">      var id=parseInt(req.params.id);</div><div class="line">      var index=_.findIndex(cars,&#123;id:id&#125;);  //根据id获得车在集合中的下标</div><div class="line">      cars.splice(index,1);   //在cars数组中删除下标从index开始的1条数据</div><div class="line">      res.send(&#123;status:<span class="string">"success"</span>, message:<span class="string">"删除成功!"</span>&#125;);  </div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = router;</div></pre></td></tr></table></figure></p>
<p>示例代码app.js：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">var express = require(<span class="string">'express'</span>);</div><div class="line">var path = require(<span class="string">'path'</span>);</div><div class="line">var favicon = require(<span class="string">'serve-favicon'</span>);</div><div class="line">var logger = require(<span class="string">'morgan'</span>);</div><div class="line">var cookieParser = require(<span class="string">'cookie-parser'</span>);</div><div class="line">var bodyParser = require(<span class="string">'body-parser'</span>);</div><div class="line"></div><div class="line">var index = require(<span class="string">'./routes/index'</span>);</div><div class="line">var users = require(<span class="string">'./routes/users'</span>);</div><div class="line">var pdts = require(<span class="string">'./routes/product'</span>);</div><div class="line">var task = require(<span class="string">'./routes/task'</span>);</div><div class="line">var cars = require(<span class="string">'./routes/cars'</span>);</div><div class="line"></div><div class="line">var app = express();</div><div class="line"></div><div class="line">//指定视图引擎为ejs</div><div class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</div><div class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</div><div class="line"></div><div class="line">// uncomment after placing your favicon <span class="keyword">in</span> /public</div><div class="line">//app.use(favicon(path.join(__dirname, <span class="string">'public'</span>, <span class="string">'favicon.ico'</span>)));</div><div class="line">app.use(logger(<span class="string">'dev'</span>));</div><div class="line">app.use(bodyParser.json());</div><div class="line">app.use(bodyParser.urlencoded(&#123; extended: <span class="literal">false</span> &#125;));</div><div class="line">app.use(cookieParser());</div><div class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>)));</div><div class="line"></div><div class="line">app.use(<span class="string">'/'</span>, index);</div><div class="line">app.use(<span class="string">'/users'</span>, users);</div><div class="line">app.use(<span class="string">'/pdt'</span>, pdts);</div><div class="line">app.use(<span class="string">"/task"</span>,task);</div><div class="line">app.use(<span class="string">"/cars"</span>,cars);</div><div class="line"></div><div class="line">// catch 404 and forward to error handler</div><div class="line">app.use(<span class="keyword">function</span>(req, res, next) &#123;</div><div class="line">  var err = new Error(<span class="string">'Not Found'</span>);</div><div class="line">  err.status = 404;</div><div class="line">  next(err);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// error handler</div><div class="line">app.use(<span class="keyword">function</span>(err, req, res, next) &#123;</div><div class="line">  // <span class="built_in">set</span> locals, only providing error <span class="keyword">in</span> development</div><div class="line">  res.locals.message = err.message;</div><div class="line">  res.locals.error = req.app.get(<span class="string">'env'</span>) === <span class="string">'development'</span> ? err : &#123;&#125;;</div><div class="line"></div><div class="line">  // render the error page</div><div class="line">  res.status(err.status || 500);</div><div class="line">  res.render(<span class="string">'error'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = app;</div></pre></td></tr></table></figure></p>
<p>参数中的json格式一定要使用标准格式，注意引号，注意Content-Type，<br>默认的Content-Type类型是：application/x-www-form-urlencoded</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;REST是英文Representational State Transfer的缩写，中文称之为“表述性状态转移”&lt;br&gt;基于HTTP协议&lt;br&gt;是另一种服务架构&lt;br&gt;传递是JSON、POX（Plain Old XML）而不是SOAP格式的数据&lt;br&gt;充分利用HTTP谓词（Verb）&lt;br&gt;侧重数据的传输，业务逻辑交给客户端自行处理&lt;br&gt;REST是一种分布式服务架构的风格约束，像Java、.Net（WCF、WebAPI）都有对该约束的实现，使URL变得更加有意义，更加简洁明了，如：&lt;br&gt;&lt;a href=&quot;http://heaxen.github.io/products/1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://heaxen.github.io/products/1&lt;/a&gt; get请求 表示获得所有产品的第1个&lt;br&gt;&lt;a href=&quot;http://heaxen.github.io/products/product&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://heaxen.github.io/products/product&lt;/a&gt; post请求 表示添加一个产品&lt;br&gt;&lt;a href=&quot;http://heaxen.github.io/products/1/price&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://heaxen.github.io/products/1/price&lt;/a&gt; get请求 表示获得第1个产品的价格&lt;br&gt;&lt;a href=&quot;http://heaxen.github.io/products/1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://heaxen.github.io/products/1&lt;/a&gt; delete请求 删除编号为1的产品&lt;/p&gt;
&lt;h2 id=&quot;REST设计需要遵循的原则&quot;&gt;&lt;a href=&quot;#REST设计需要遵循的原则&quot; class=&quot;headerlink&quot; title=&quot;REST设计需要遵循的原则&quot;&gt;&lt;/a&gt;REST设计需要遵循的原则&lt;/h2&gt;&lt;p&gt;网络上的所有事物都被抽象为资源（resource）；&lt;br&gt;每个资源对应一个唯一的资源标识符（resource identifier）；&lt;br&gt;通过通用的连接器接口（generic connector interface）对资源进行操作；&lt;br&gt;对资源的各种操作不会改变资源标识符；&lt;br&gt;所有的操作都是无状态的（stateless）&lt;/p&gt;
&lt;h2 id=&quot;谓词&quot;&gt;&lt;a href=&quot;#谓词&quot; class=&quot;headerlink&quot; title=&quot;谓词&quot;&gt;&lt;/a&gt;谓词&lt;/h2&gt;&lt;p&gt;GET&lt;br&gt;表示查询操作，相当于Retrieve、Select操作&lt;br&gt;POST&lt;br&gt;表示插入操作，相当于Create，Insert操作&lt;br&gt;PUT&lt;br&gt;表示修改操作，相当于Update操作&lt;br&gt;DELETE&lt;br&gt;表示删除操作，相当于Delete操作&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="node.js , express , RESTful" scheme="http://weibo.com/categories/node-js-express-RESTful/"/>
    
    
      <category term="RESTful" scheme="http://weibo.com/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>Express框架实例</title>
    <link href="http://weibo.com/2017/08/16/Express%E6%A1%86%E6%9E%B6%E5%AE%9E%E4%BE%8B/"/>
    <id>http://weibo.com/2017/08/16/Express框架实例/</id>
    <published>2017-08-16T06:01:47.000Z</published>
    <updated>2017-08-16T11:31:14.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Express？"><a href="#什么是Express？" class="headerlink" title="什么是Express？"></a>什么是Express？</h2><p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。<br>使用 Express 可以快速地搭建一个完整功能的网站。使用Node.js作为AngularJS开发Web服务器的最佳方式是使用Express模块。<br><a href="http://expressjs.com/" target="_blank" rel="external">Express官网：</a><br><a href="http://expressjs.com/zh-cn/4x/api.html" target="_blank" rel="external">Express4.x API: </a></p>
<h2 id="Express框架核心特性"><a href="#Express框架核心特性" class="headerlink" title="Express框架核心特性"></a>Express框架核心特性</h2><p>可以设置中间件来响应 HTTP 请求。<br>定义了路由表用于执行不同的 HTTP 请求动作。<br>可以通过向模板传递参数来动态渲染 HTML 页面。<br>丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。<br>Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。<br><a id="more"></a></p>
<h2 id="安装Express"><a href="#安装Express" class="headerlink" title="安装Express"></a>安装Express</h2><p>安装 Express 并将其保存到依赖列表中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install express --save</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install express -g</div></pre></td></tr></table></figure>
<p>以上命令全局安装express，同时也可以指定安装中间件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install body−parser −−save    (用于处理 JSON, Raw, Text 和 URL 编码的数据)</div><div class="line">npm install cookie-parser --save  (解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象)</div><div class="line">npm install multer --save         (用于处理 enctype=<span class="string">"multipart/form-data"</span>（设置表单的MIME编码）的表单数据)</div></pre></td></tr></table></figure></p>
<p>默认这些模块都已经添加。</p>
<h2 id="Express框架实例"><a href="#Express框架实例" class="headerlink" title="Express框架实例"></a>Express框架实例</h2><p>hello.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//引入express模块</div><div class="line">var express = require(<span class="string">'express'</span>);</div><div class="line">//创建一个app对象，类似一个web应用(网站)</div><div class="line">var app = express();</div><div class="line">//接受指定路径的请求，指定回调函数</div><div class="line">app.get(<span class="string">'/'</span>, <span class="keyword">function</span> (req, res)&#123;</div><div class="line">    res.send(<span class="string">'Hello World'</span>);</div><div class="line">&#125;);</div><div class="line">//创建一个web服务器，可以认为就是web服务器对象</div><div class="line">//监听8081端口，当监听成功时回调</div><div class="line">var server = app.listen(8081, <span class="function"><span class="title">funcrtion</span></span> ()&#123;</div><div class="line">    var host = server.address().address;  //地址</div><div class="line">    var port = server.address().port;     //端口</div><div class="line">    console.log(<span class="string">"应用实例，访问地址为http://%s:%s"</span>,host,port);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>找到此文件对应的文件夹，在node环境下解释运行hello.js就可以命令行看到打印信息，在浏览器出入127.0.0.1:8081可以看到输出字符。</p>
<h2 id="新建-NodeJs-Express-项目"><a href="#新建-NodeJs-Express-项目" class="headerlink" title="新建 NodeJs Express 项目"></a>新建 NodeJs Express 项目</h2><p>app.js是网站：<br>bin\www是web服务器：<br>views/index.ejs首页视图：</p>
<h2 id="什么是ejs？"><a href="#什么是ejs？" class="headerlink" title="什么是ejs？"></a>什么是ejs？</h2><p>ejs是一个Express Web应用的模板引擎，在NodeJS开发中可以选择的模板引擎可能是所有Web应用开发中范围最广的，如jade、ejs、htmljs、swig、hogan.js，但ejs是最容易上手的，与jsp,asp,php的原始模板引擎风格很像。<br><a href="http://www.embeddedjs.com/" target="_blank" rel="external">官网：http://www.embeddedjs.com/</a></p>
<h3 id="在routes目录下添加一个product-js路由"><a href="#在routes目录下添加一个product-js路由" class="headerlink" title="在routes目录下添加一个product.js路由"></a>在routes目录下添加一个product.js路由</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var express = require(<span class="string">'express'</span>);</div><div class="line">var router = express.Router();</div><div class="line"></div><div class="line">/*产品*/</div><div class="line">router.get(<span class="string">'/'</span>, <span class="keyword">function</span>(req, res, next)&#123;</div><div class="line">    var products = [];</div><div class="line">    products.push(&#123;name:<span class="string">"moto zx"</span>,price:2388.8&#125;);</div><div class="line">    products.push(&#123;name:<span class="string">"xiaomi mix"</span>,price:3288.8&#125;);</div><div class="line">    products.push(&#123;name:<span class="string">"iphone7 plus"</span>,price:5888.8&#125;);</div><div class="line"></div><div class="line">    //将product视图与指定的对象渲染后输出到客户端</div><div class="line">    res.render(<span class="string">'priduct'</span>,&#123;title:<span class="string">'京狗商城'</span>,pdts:products&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = router;</div></pre></td></tr></table></figure>
<h3 id="在views目录下添加product-ejs视图，这里是一个简单的MVC："><a href="#在views目录下添加product-ejs视图，这里是一个简单的MVC：" class="headerlink" title="在views目录下添加product.ejs视图，这里是一个简单的MVC："></a>在views目录下添加product.ejs视图，这里是一个简单的MVC：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line"></div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;</div><div class="line">        &lt;%= title %&gt;</div><div class="line">    &lt;/title&gt;</div><div class="line">    &lt;link rel=<span class="string">'stylesheet'</span> href=<span class="string">'/stylesheets/style.css'</span> /&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;h1&gt;&lt;%= title %&gt; - 产品列表&lt;/h1&gt;</div><div class="line">&lt;table border=<span class="string">"1"</span> width=<span class="string">"80%"</span>&gt;</div><div class="line">    &lt;tr&gt;</div><div class="line">        &lt;th&gt;序号&lt;/th&gt;</div><div class="line">        &lt;th&gt;名称&lt;/th&gt;</div><div class="line">        &lt;th&gt;价格&lt;/th&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">    &lt;%pdts.forEach(<span class="keyword">function</span>(pdt,index)&#123;%&gt;</div><div class="line">    &lt;tr&gt;</div><div class="line">        &lt;td&gt;</div><div class="line">            &lt;%=index+1%&gt;</div><div class="line">        &lt;/td&gt;</div><div class="line">        &lt;td&gt;</div><div class="line">            &lt;%=pdt.name%&gt;</div><div class="line">        &lt;/td&gt;</div><div class="line">        &lt;td&gt;</div><div class="line">            &lt;%=pdt.price%&gt;</div><div class="line">        &lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">    &lt;%&#125;);%&gt;</div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">&lt;ul&gt;</div><div class="line">    &lt;% <span class="keyword">for</span>(var i=0; i&lt;pdts.length; i++) &#123;%&gt;</div><div class="line">    &lt;li&gt;</div><div class="line">        &lt;%=pdts[i].name%&gt;</div><div class="line">    &lt;/li&gt;</div><div class="line">    &lt;% &#125; %&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>修改app，注册定义好的模块product：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var index = require(<span class="string">'./routes/index'</span>);</div><div class="line">var users = require(<span class="string">'./routes/users'</span>);</div><div class="line">var pdts = require(<span class="string">'./routes/product'</span>);</div><div class="line"></div><div class="line">var app = express();</div><div class="line"></div><div class="line">//指定视图引擎为ejs</div><div class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</div><div class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</div><div class="line"></div><div class="line">// uncomment after placing your favicon <span class="keyword">in</span> /public</div><div class="line">//app.use(favicon(path.join(__dirname, <span class="string">'public'</span>, <span class="string">'favicon.ico'</span>)));</div><div class="line">app.use(logger(<span class="string">'dev'</span>));</div><div class="line">app.use(bodyParser.json());</div><div class="line">app.use(bodyParser.urlencoded(&#123; extended: <span class="literal">false</span> &#125;));</div><div class="line">app.use(cookieParser());</div><div class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>)));</div><div class="line"></div><div class="line">app.use(<span class="string">'/'</span>, index);</div><div class="line">app.use(<span class="string">'/users'</span>, users);</div><div class="line">app.use(<span class="string">'/pdt'</span>, pdts);</div></pre></td></tr></table></figure></p>
<h2 id="什么是lodash？"><a href="#什么是lodash？" class="headerlink" title="什么是lodash？"></a>什么是lodash？</h2><p>这是一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库。可以非常方便的操作json。<br><a href="http://lodashjs.com/" target="_blank" rel="external">官网：http://lodashjs.com/</a><br>安装：<br>npm i -g npm<br>npm i –save lodash<br>安装时先用cd切换到当前项目下。<br>如果浏览器使用可以直接引入：</p>
<p><script src="lodash.js"></script><br>后台Node.js使用，可以引入模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//导入lodash模块</div><div class="line">var _= require(<span class="string">'lodash'</span>);</div><div class="line"></div><div class="line">var products=[];</div><div class="line">products.push(&#123;name:<span class="string">"ZTE U880"</span>,price:899.8&#125;);</div><div class="line">products.push(&#123;name:<span class="string">"HuWei 荣耀8"</span>,price:1899.8&#125;);</div><div class="line">products.push(&#123;name:<span class="string">"iPhone 7 Plus 128G"</span>,price:5899.8&#125;);</div><div class="line"></div><div class="line">//1、取出第一个元素</div><div class="line">var obj1=_.first(products);</div><div class="line">console.log(obj1.name);  //ZTE U880</div><div class="line"></div><div class="line">//2、取出最后一个元素</div><div class="line">var obj2=_.last(products);</div><div class="line">console.log(obj2.name);  //iPhone 7 Plus 128G</div><div class="line"></div><div class="line">//3、指定查找条件返回符合条件的索引</div><div class="line">var obj3=_.findIndex(products,<span class="keyword">function</span>(obj)&#123;</div><div class="line">    <span class="built_in">return</span> obj.price&gt;=1000&amp;&amp;obj.name.indexOf(<span class="string">"7"</span>)&gt;0;</div><div class="line">&#125;);</div><div class="line">console.log(obj3);  //2</div><div class="line"></div><div class="line">//4、指定查找条件返回查找到的对象</div><div class="line">var obj4=_.find(products,<span class="keyword">function</span>(obj)&#123;</div><div class="line">    <span class="built_in">return</span> obj.price&gt;=1000&amp;&amp;obj.name.indexOf(<span class="string">"7"</span>)&gt;0;</div><div class="line">&#125;);</div><div class="line">console.log(obj4);  //&#123; name: <span class="string">'iPhone 7 Plus 128G'</span>, price: 5899.8 &#125;</div><div class="line"></div><div class="line">//5、排序</div><div class="line">var obj5=_.orderBy(products,[<span class="string">"price"</span>,<span class="string">"name"</span>],[<span class="string">"desc"</span>,<span class="string">"asc"</span>]);</div><div class="line">console.log(obj5); </div><div class="line"></div><div class="line">//6、查找价格为1899.8的产品的key</div><div class="line">var obj6=_.findKey(products,&#123;price:1899.8&#125;);</div><div class="line">console.log(obj6);   //1</div></pre></td></tr></table></figure></p>
<p>API的使用非常简单，但需要注意版本，可以现查现用。<br><a href="https://lodash.com/docs/4.17.2" target="_blank" rel="external">API地址：https://lodash.com/docs/4.17.2</a></p>
<h2 id="URL中的参数占位"><a href="#URL中的参数占位" class="headerlink" title="URL中的参数占位"></a>URL中的参数占位</h2><p>Checks route params (req.params), ex: /user/:id<br>127.0.0.1:3000/index，这种情况下，我们为了得到index，我们可以通过使用req.params得到，通过这种方法我们就可以很好的处理Node中的路由处理问题，同时利用这点可以非常方便的实现MVC模式；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//获得产品根据Id</div><div class="line">router.get(<span class="string">'/:id/:category'</span>,<span class="keyword">function</span>(request,res,next)&#123;</div><div class="line">    res.send(request.params.id+<span class="string">","</span>+request.params.category);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="URL中的QueryString"><a href="#URL中的QueryString" class="headerlink" title="URL中的QueryString"></a>URL中的QueryString</h2><p>Checks query string params (req.query), ex: ?id=12<br>127.0.0.1:3000/index?id=12，这种情况下，这种方式是获取客户端get方式传递过来的值，通过使用req.query.id就可以获得，类似于PHP的get方法；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">router.get(<span class="string">'/:id'</span>,<span class="keyword">function</span>(request,res,next)&#123;</div><div class="line">    res.send(<span class="string">"name:"</span>+request.query.name);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="HTTP正文中的参数"><a href="#HTTP正文中的参数" class="headerlink" title="HTTP正文中的参数"></a>HTTP正文中的参数</h2><p> 在post请求中获得表单中的数据。<br>Checks urlencoded body params (req.body), ex: id=<br>127.0.0.1:3000/index，然后post了一个id=2的值，这种方式是获取客户端post过来的数据，可以通过req.body.id获取，类似于PHP的post方法；</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>如果需要Node.js向外提供返回JSON的接口，Express也是非常方便的，可以使用原来在浏览器中使用到的JSON对象，这是一个浏览器内置对象在服务可以直接使用：<br>将对象序列化成字符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//对象</div><div class="line">var rose=&#123;<span class="string">"name"</span>:<span class="string">"Rose"</span>,<span class="string">"weight"</span>:<span class="string">"65"</span>&#125;;</div><div class="line">//序列化成字符串</div><div class="line">var str=JSON.stringify(rose);</div><div class="line">alert(str);</div></pre></td></tr></table></figure></p>
<p>反序列化，将字符转换成对象：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//将字符串转换成JavaScript对象</div><div class="line">var markStr=<span class="string">'&#123;"name":"mark","weight":"188"&#125;'</span>;</div><div class="line">var mark=JSON.parse(markStr);</div><div class="line">alert(mark.name+<span class="string">"，"</span>+mark.weight);</div></pre></td></tr></table></figure></p>
<p>Express已经封装了一个json方法，直接调用该方法就可以序列化对象：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* 产品 */</div><div class="line">router.get(<span class="string">'/rest'</span>, <span class="keyword">function</span>(req, res, next) &#123;</div><div class="line">  res.json(products);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Express？&quot;&gt;&lt;a href=&quot;#什么是Express？&quot; class=&quot;headerlink&quot; title=&quot;什么是Express？&quot;&gt;&lt;/a&gt;什么是Express？&lt;/h2&gt;&lt;p&gt;Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。&lt;br&gt;使用 Express 可以快速地搭建一个完整功能的网站。使用Node.js作为AngularJS开发Web服务器的最佳方式是使用Express模块。&lt;br&gt;&lt;a href=&quot;http://expressjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Express官网：&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://expressjs.com/zh-cn/4x/api.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Express4.x API: &lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Express框架核心特性&quot;&gt;&lt;a href=&quot;#Express框架核心特性&quot; class=&quot;headerlink&quot; title=&quot;Express框架核心特性&quot;&gt;&lt;/a&gt;Express框架核心特性&lt;/h2&gt;&lt;p&gt;可以设置中间件来响应 HTTP 请求。&lt;br&gt;定义了路由表用于执行不同的 HTTP 请求动作。&lt;br&gt;可以通过向模板传递参数来动态渲染 HTML 页面。&lt;br&gt;丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。&lt;br&gt;Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="node.js , express" scheme="http://weibo.com/categories/node-js-express/"/>
    
    
      <category term="express , web" scheme="http://weibo.com/tags/express-web/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs开发Web后台服务</title>
    <link href="http://weibo.com/2017/08/16/NodeJs%E5%BC%80%E5%8F%91Web%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1/"/>
    <id>http://weibo.com/2017/08/16/NodeJs开发Web后台服务/</id>
    <published>2017-08-16T04:28:11.000Z</published>
    <updated>2017-08-16T11:27:31.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>什么是Node.js?<br>Node.js 是一个基于Google Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。<br>能方便地搭建响应速度快、易于扩展的网络应用，Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。<br>简单说Node.js就是运行在服务器端的JavaScript，是现在流行的语言中能同时运行在前端与后台的程序语言，你可以把JavaScript想像成Java与C#。<br><a href="https://nodejs.org/en/" target="_blank" rel="external">官网</a>,<a href="http://nodejs.cn/" target="_blank" rel="external">中文</a>,<a href="http://nodeapi.ucdok.com/#/api/" target="_blank" rel="external">API</a><br>相关技术：<br>数据库：    MongoDB，非关系型数据库，NoSQL（Not only SQL）<br>MVC框架：   AngularJS<br>Web服务器： Express<br>模板引擎：  jade、ejs、htmljs、swig、hogan.js<br><a id="more"></a></p>
<h2 id="编写第一个Node-js程序"><a href="#编写第一个Node-js程序" class="headerlink" title="编写第一个Node.js程序"></a>编写第一个Node.js程序</h2><p>server.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//依赖一个http模块，相当于Java中的import，与C<span class="comment">#中的using</span></div><div class="line">var http = require(<span class="string">'http'</span>);</div><div class="line">//创建一个服务器对象</div><div class="line">server = http.createServer(<span class="keyword">function</span> (req, res) &#123;</div><div class="line">//设置请求成功时响应头部的MIME为纯文本</div><div class="line">    res.writeHeader(200,&#123;<span class="string">"Content-Type"</span>:<span class="string">"text/plain"</span>&#125;);</div><div class="line">//向客户端输出字符</div><div class="line">    res.end(<span class="string">"Hello World\n"</span>);</div><div class="line">&#125;);</div><div class="line">//让服务器监听本地8000端口开始运行</div><div class="line">server.listen(8000,<span class="string">'127.0.0.1'</span>);</div><div class="line">console.log(<span class="string">"Server is running at 127.0.0.1:8000"</span>);</div></pre></td></tr></table></figure></p>
<p>找到此文件对应的文件夹，在node环境下解释运行server.js就可以命令行看到打印信息，在浏览器出入127.0.0.1:8000可以看到输出字符。</p>
<h2 id="NPM-Node-js管理包"><a href="#NPM-Node-js管理包" class="headerlink" title="NPM(Node.js管理包)"></a>NPM(Node.js管理包)</h2><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：<br>a)、允许用户从NPM服务器下载别人编写的第三方包到本地使用。<br>b)、允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。<br>c)、允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。<br>官网地址:<a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a><br>查看npm版本：   npm -v<br>升级npm：       npm install npm -g<br>安装模块：      npm install <module name=""> -g (-g表示全局安装，否则只是安装到摸个目录下)<br>卸载模块：      npm uninstall <module name=""><br>查看模块列表：  npm ls<br>更新模块：      npm update <module name=""> , npm up -g <module name=""><br>搜索模块：      npm search <module name=""></module></module></module></module></module></p>
<h2 id="NPM-常用命令"><a href="#NPM-常用命令" class="headerlink" title="NPM 常用命令"></a>NPM 常用命令</h2><p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。<br>a)、npm help <command><br>可查看某条命令的详细帮助，例如npm help install。<br>b)、在package.json所在目录下使用npm  install . -g<br>可先在本地安装当前命令行程序，可用于发布前的本地测试。<br>c)、npm update <package><br>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。<br>d)、npm update <package> -g<br>可以把全局安装的对应命令行程序更新至最新版。<br>e)、npm cache clear<br>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。<br>f)、npm unpublish <package>@<version><br>可以撤销发布自己发布过的某个版本代码。</version></package></package></package></p>
<h2 id="更换NPM镜像"><a href="#更换NPM镜像" class="headerlink" title="更换NPM镜像"></a>更换NPM镜像</h2><p>淘宝 NPM 镜像<a href="http://npm.taobao.org/" target="_blank" rel="external">http://npm.taobao.org/</a>为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure></p>
<p>这样就可以使用 cnpm 命令来安装模块了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cnpm install &lt;module name&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;什么是Node.js?&lt;br&gt;Node.js 是一个基于Google Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。&lt;br&gt;能方便地搭建响应速度快、易于扩展的网络应用，Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。&lt;br&gt;简单说Node.js就是运行在服务器端的JavaScript，是现在流行的语言中能同时运行在前端与后台的程序语言，你可以把JavaScript想像成Java与C#。&lt;br&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;,&lt;a href=&quot;http://nodejs.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中文&lt;/a&gt;,&lt;a href=&quot;http://nodeapi.ucdok.com/#/api/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;API&lt;/a&gt;&lt;br&gt;相关技术：&lt;br&gt;数据库：    MongoDB，非关系型数据库，NoSQL（Not only SQL）&lt;br&gt;MVC框架：   AngularJS&lt;br&gt;Web服务器： Express&lt;br&gt;模板引擎：  jade、ejs、htmljs、swig、hogan.js&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="node.js , web" scheme="http://weibo.com/categories/node-js-web/"/>
    
    
      <category term="node.js , web" scheme="http://weibo.com/tags/node-js-web/"/>
    
  </entry>
  
</feed>
